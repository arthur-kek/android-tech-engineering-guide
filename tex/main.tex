\UseRawInputEncoding
\documentclass[a4paper,12pt]{article}

% ---------- Packages ----------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{titlesec}
\usepackage{geometry}
\usepackage{array}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\setcounter{tocdepth}{3}

% ---------- Page Setup ----------
\geometry{margin=1in}

% ---------- Listings Global Settings ----------
\definecolor{lightgray}{gray}{0.95}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codeblue}{rgb}{0.2,0.2,0.7}
\definecolor{codeorange}{rgb}{0.8,0.4,0.1}

\lstset{
  backgroundcolor=\color{lightgray},
  basicstyle=\ttfamily\small,
  frame=single,
  breaklines=true,
  breakatwhitespace=false,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  showstringspaces=false,
  showspaces=false,
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=10pt,
  tabsize=2,
  keywordstyle=\color{codeblue},
  commentstyle=\color{codegray},
  stringstyle=\color{codeorange},
  literate=
    {–}{{-{-}}}1
    {—}{{---}}1
    {“}{{``}}1
    {”}{{''}}1
    {’}{{'}}1
    {‘}{{'}}1
    {×}{{x}}1
    {⇧}{{Shift}}1
    {⌘}{{Cmd}}1
    {✗}{{x}}1
    {✓}{{\checkmark}}1
}

% ---------- Language Definitions ----------
\lstdefinelanguage{kotlin}{
  morekeywords={
    fun, val, var, if, else, for, while, when, return, class, interface, object,
    override, import, package, is, in, as, typealias, typeof,
    try, catch, finally, throw, this, super, do, break, continue, 
    public, private, protected, internal, open, final, abstract, override, lateinit, const,
    true, false, null, companion, init, constructor, by, get, set, field, it,
    enum, sealed, data, inline, infix, tailrec, external, suspend, operator,
    reified, vararg, noinline, crossinline, expect, actual, out, in,
    Unit, Any, Nothing, String, Int, Double, Float, Boolean, Long, Short, Byte, Char,
    suspend, coroutineScope, withContext, delay, launch, async, runBlocking, flow, collect,
    StateFlow, SharedFlow, remember, rememberSaveable, derivedStateOf, mutableStateOf,
    viewModel, collectAsState, LaunchedEffect, SideEffect, DisposableEffect,
    rememberCoroutineScope
  },
  morekeywords=[2]{@Composable, @JvmStatic, @JvmOverloads, @JvmField, @Volatile, @Synchronized, @Deprecated, @Suppress, @Inject},
  keywordstyle=\color{codeblue},
  keywordstyle=[2]\color{purple},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{codegray},
  morestring=[b]",
  stringstyle=\color{codeorange},
}

\lstdefinelanguage{bash}{
  morekeywords={cd, ls, mv, rm, mkdir, rmdir, touch, echo, sudo, apt, git},
  sensitive=true,
  morecomment=[l]{\#},
  morestring=[b]",
}

\lstdefinelanguage{Groovy}{
  morekeywords={
    abstract, as, assert, break, case, catch, class, const, continue, def, default,
    do, else, enum, extends, false, final, finally, for, goto, if, implements, import,
    in, instanceof, interface, new, null, package, return, super, switch, this, throw,
    throws, trait, true, try, while
  },
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}

% ---------- Document ----------
\begin{document}

\begin{titlepage}
  \centering
  \vspace*{3cm}
  {\Huge \bfseries Modern Software Engineering and Android Internals: \\[0.5em]
  Technical Guide \par}
  \vspace{5cm}
  \vfill
  {\large Last Updated: \today\par}
\end{titlepage}

\clearpage
\tableofcontents
\clearpage
\pagenumbering{arabic}

\section{Object-Oriented Principles}

\subsection{Structural Quality Fundamentals}
\subsubsection{Cohesion and Coupling}

\textbf{What:} Cohesion defines how strongly related and focused the responsibilities of a module are. Coupling defines how much a module depends on others.

\textbf{Why:} High cohesion and low coupling improve modularity, enable safer refactoring, and reduce unintended side effects. These two qualities form the structural backbone of maintainable object-oriented systems.

\subsubsection{Cohesion}

\textbf{Definition:} A measure of internal alignment. A highly cohesive module does one job and does it completely.

\begin{lstlisting}[language=Java]
// High cohesion
class AuthService {
    boolean authenticate(String username, String password) { ... }
}
\end{lstlisting}

\textbf{Focus Point:} Favor single-purpose classes. Split responsibilities when a class starts handling unrelated concerns.

\subsubsection{Coupling}

\textbf{Definition:} A measure of external dependency. Low coupling means a module interacts through abstractions, not concrete implementations.

\begin{lstlisting}[language=Java]
// Low coupling via interface
interface Printer {
    void print(String data);
}

class ReportPrinter {
    private final Printer printer;

    ReportPrinter(Printer printer) {
        this.printer = printer;
    }

    void printReport(String report) {
        printer.print(report);
    }
}
\end{lstlisting}

\textbf{Focus Point:} Depend on interfaces, not implementations. Decouple policies (what) from mechanisms (how).

\subsubsection{Impact}

\begin{itemize}
  \item \textbf{High cohesion} localizes logic and reduces class complexity.
  \item \textbf{Low coupling} isolates change, simplifies testing and reuse.
\end{itemize}

\textbf{Focus Point:} Each module should be internally tight (cohesion) and externally loose (coupling). These qualities are critical across all layers of software architecture, from class design to modular systems.

\subsection{SOLID Principles}

SOLID is a mnemonic acronym for five design principles in object-oriented programming: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion. Each principle targets a different axis of code quality: modularity, extensibility, substitutability, cohesion, and coupling.

\subsubsection{S - Single Responsibility Principle (SRP)}

\textbf{What:} A module should have only one reason to change.

\textbf{Why:} A “reason to change” means a distinct axis of responsibility. When a class has multiple responsibilities (e.g. business logic, persistence, rendering), changes in one concern can cause unintentional side effects in the others. This increases coupling and fragility.

\textbf{How:} Split by responsibility axis. Identify concerns that evolve independently, and isolate them in different classes or components.

\begin{lstlisting}[language=Java]
// Violation: mixes business logic, IO, and formatting
class Invoice {
    void calculateTotal() { ... }     // business rule
    void printInvoice() { ... }       // presentation
    void saveToDatabase() { ... }     // persistence
}
\end{lstlisting}

This class will change if:
- business rules evolve (e.g. discounts or tax rules),
- a new database is introduced,
- formatting requirements change.

\begin{lstlisting}[language=Java]
// Solution: one class per responsibility
class Invoice {
    void calculateTotal() { ... }
}

class InvoicePrinter {
    void print(Invoice invoice) { ... }
}

class InvoiceRepository {
    void save(Invoice invoice) { ... }
}
\end{lstlisting}

Now, each change is localized and isolated. The business logic can evolve independently from IO or storage logic.

\textbf{Focus Point:} Think in terms of “reasons to change”. If a class changes for more than one reason, extract one of the responsibilities.

\subsubsection{O - Open/Closed Principle (OCP)}

\textbf{What:} Software entities should be open for extension but closed for modification.

\textbf{Why:} Changing existing, working code can introduce regressions. By designing for extension, new behavior can be added without touching stable components, preserving reliability and minimizing risk.

\textbf{How:} Favor abstraction and polymorphism. Move variability out of core logic into interchangeable modules.

\begin{lstlisting}[language=Java]
// Violation: every new case requires modifying logic
class DiscountCalculator {
    double calculate(String type, double amount) {
        if (type.equals("REGULAR")) return amount * 0.9;
        if (type.equals("PREMIUM")) return amount * 0.8;
        return amount;
    }
}
\end{lstlisting}

This approach forces developers to reopen and edit the `DiscountCalculator` class whenever new discount types are added. It tightly couples the logic to all discount variations, violating OCP.

\begin{lstlisting}[language=Java]
// Solution: new logic via polymorphism, not modification
interface Discount {
    double apply(double amount);
}

class RegularDiscount implements Discount {
    public double apply(double amount) {
        return amount * 0.9;
    }
}

class PremiumDiscount implements Discount {
    public double apply(double amount) {
        return amount * 0.8;
    }
}

class DiscountCalculator {
    double calculate(Discount discount, double amount) {
        return discount.apply(amount);
    }
}
\end{lstlisting}

New discount types (e.g. `StudentDiscount`, `BlackFridayDiscount`) can be introduced without touching existing code. This promotes stability and extensibility.

\textbf{Focus Point:} Apply the Strategy pattern to encapsulate variations. This decouples policies from algorithms and supports runtime injection of new behavior.

\textbf{Deep Dive:}  
At the bytecode level, the difference between the two approaches is critical for JIT optimization. Monolithic \texttt{if-else} trees hinder method inlining and introduce branch misprediction. In contrast, polymorphism enables class-level modularization and cleaner call-site resolution, benefiting both runtime performance and testability.

\subsubsection{L - Liskov Substitution Principle (LSP)}

\textbf{What:} Subtypes must be substitutable for their base types without altering program correctness.

\textbf{Why:} If a subclass violates the expected behavior of its superclass, it breaks polymorphism. Consumers relying on the superclass should not need awareness of subclass-specific behavior to avoid bugs.

\textbf{How:} Preserve all contracts defined by the base type — preconditions must not be strengthened, postconditions must not be weakened, and invariants must be maintained.

\begin{lstlisting}[language=Java]
// Violation: breaks area logic assumptions
class Rectangle {
    int width, height;
    void setWidth(int w) { width = w; }
    void setHeight(int h) { height = h; }
    int area() { return width * height; }
}

class Square extends Rectangle {
    void setWidth(int w) { width = height = w; }
    void setHeight(int h) { width = height = h; }
}
\end{lstlisting}

Client code expecting independent width/height control behaves incorrectly when passed a `Square`, violating the LSP.

\begin{lstlisting}[language=Java]
// Solution: separate hierarchy to avoid invalid substitution
interface Shape {
    int area();
}

class Rectangle implements Shape {
    int width, height;
    Rectangle(int w, int h) { width = w; height = h; }
    public int area() { return width * height; }
}

class Square implements Shape {
    int side;
    Square(int s) { side = s; }
    public int area() { return side * side; }
}
\end{lstlisting}

By removing inheritance, we avoid coupling incompatible semantics. Both classes satisfy the `Shape` contract without risking behavior override issues.

\textbf{Focus Point:} Never inherit just for reuse. Inheritance must model true “is-a” relationships — behavioral substitutability, not structural similarity, is the key.

\textbf{Deep Dive:}  
LSP violations often manifest as runtime bugs in client code when subclass-specific logic leaks into shared contracts. From a type-theory perspective, violating LSP breaks the substitutability invariant and causes variance mismatches. Many frameworks (e.g., DI containers, UI frameworks) implicitly rely on LSP to enable inversion of control, mocking, and reuse.

\subsubsection{I - Interface Segregation Principle (ISP)}

\textbf{What:} Clients should not be forced to depend on methods they do not use.

\textbf{Why:} Fat interfaces force implementers to provide irrelevant or artificial behavior, reducing cohesion and increasing maintenance overhead. Violations often lead to runtime exceptions or misleading contracts.

\textbf{How:} Break monolithic interfaces into multiple, smaller interfaces that group behavior by responsibility. Classes then implement only the interfaces they actually require.

\begin{lstlisting}[language=Java]
// Violation: forces unrelated responsibilities on implementers
interface Machine {
    void print();
    void scan();
    void fax();
}

class SimplePrinter implements Machine {
    public void print() {}
    public void scan() { throw new UnsupportedOperationException(); }
    public void fax() { throw new UnsupportedOperationException(); }
}
\end{lstlisting}

The implementer is only interested in printing, but is coupled to scan/fax operations, leading to broken expectations and poor design.

\begin{lstlisting}[language=Java]
// Solution: segregated interfaces
interface Printer {
    void print();
}

interface Scanner {
    void scan();
}

interface Fax {
    void fax();
}

class SimplePrinter implements Printer {
    public void print() {}
}
\end{lstlisting}

Each interface is cohesive, with no extraneous operations. Implementers only commit to relevant contracts.

\textbf{Focus Point:} Favor fine-grained, role-specific interfaces. If you must implement a method you don’t use, that’s a design smell.

\textbf{Deep Dive:}  
ISP aligns with the concept of \textit{interface role typing}. This separation improves dependency graphs, testability, and mocking. Frameworks like Spring, Dagger, and Retrofit benefit directly by injecting narrowly defined interfaces that minimize contract surface and improve substitution flexibility.

\subsubsection{D - Dependency Inversion Principle (DIP)}

\textbf{What:} High-level modules should not depend on low-level modules. Both should depend on abstractions.

\textbf{Why:} Direct dependencies on concrete implementations tightly couple the system, making it harder to test, extend, or reuse components. Changes to low-level modules ripple through the system, violating encapsulation.

\textbf{How:} Define stable abstractions (interfaces or abstract classes) and inject their implementations at runtime via constructors, factories, or frameworks.

\begin{lstlisting}[language=Java]
// Violation: tight coupling to a concrete class
class MySQLDatabase {
    void save(String data) {}
}

class UserService {
    private MySQLDatabase db = new MySQLDatabase();
    void register(String data) {
        db.save(data);
    }
}
\end{lstlisting}

The high-level \texttt{UserService} is directly tied to a specific persistence strategy. This prevents reuse with alternatives and makes testing harder.

\begin{lstlisting}[language=Java]
// Solution: inversion via abstraction
interface Database {
    void save(String data);
}

class MySQLDatabase implements Database {
    public void save(String data) {}
}

class UserService {
    private final Database db;
    UserService(Database db) { this.db = db; }

    void register(String data) {
        db.save(data);
    }
}
\end{lstlisting}

\texttt{UserService} now depends on an abstraction, enabling decoupling from the actual storage engine.

\textbf{Focus Point:} DIP is a prerequisite for dependency injection. It allows substitution (e.g., mocks, stubs), improves testability, and enables architecture layering.

\textbf{Deep Dive:}  
DIP inverts the direction of control flow. Rather than high-level modules invoking low-level code directly, they invoke interfaces that are bound externally. This pattern underpins Inversion of Control (IoC) containers such as Dagger, Koin, or Spring. Properly applied, it isolates domain logic from framework and infrastructure concerns.


\subsection{Object-Oriented Foundations}

\subsubsection{Core Principles of OOP}

Object-Oriented Programming (OOP) is structured around four foundational principles: encapsulation, inheritance, polymorphism, and abstraction. Each pillar enforces modularity and maintainability by managing data and behavior coupling.

\subsubsection{Encapsulation}

\textbf{What:} Bundles data and behavior inside a class, restricting direct access to internal state.

\textbf{Why:} Prevents external interference, reduces coupling, and protects invariants.

\textbf{How:} Use access modifiers (\texttt{private}, \texttt{protected}) and controlled exposure via methods.

\begin{lstlisting}[language=Java]
class BankAccount {
    private double balance;

    public void deposit(double amount) {
        if (amount > 0) balance += amount;
    }

    public double getBalance() {
        return balance;
    }
}
\end{lstlisting}


\textbf{Focus Point:} Always encapsulate mutable state. Public fields break object integrity.

\subsubsection{Inheritance}

\textbf{What:} A class derives behavior and structure from another class via an \texttt{extends} or \texttt{implements} relationship.

\textbf{Why:} Promotes reuse of shared logic and defines hierarchical relationships.

\textbf{How:} Define shared logic in a superclass, and use subclasses to extend or specialize it.

\begin{lstlisting}[language=Java]
class Animal {
    void speak() { System.out.println("..."); }
}

class Dog extends Animal {
    void speak() { System.out.println("Woof"); }
}
\end{lstlisting}

\textbf{Focus Point:} Inheritance introduces tight coupling. Prefer composition if extension is not strictly necessary.

\subsubsection{Polymorphism}

\textbf{What:} The same interface or method name behaves differently based on the runtime object.

\textbf{Why:} Enables decoupling from specific implementations and supports flexible behavior extension.

\textbf{How:} Implement method overriding via inheritance or interface implementation.

\begin{lstlisting}[language=Java]
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() { System.out.println("Draw Circle"); }
}

class Square implements Shape {
    public void draw() { System.out.println("Draw Square"); }
}
\end{lstlisting}

\texttt{Shape} references can hold either \texttt{Circle} or \texttt{Square} at runtime.

\textbf{Focus Point:} Always program to an interface, not a concrete implementation.

\subsubsection{Abstraction}

\textbf{What:} Exposes only the essential features of a class, hiding internal complexity.

\textbf{Why:} Reduces cognitive load and enforces design contracts.

\textbf{How:} Use interfaces and abstract classes to define APIs.

\begin{lstlisting}[language=Java]
interface Storage {
    void save(String data);
}

class FileStorage implements Storage {
    public void save(String data) {
        // write to file
    }
}
\end{lstlisting}

Clients depend on the abstraction \texttt{Storage}, not on the concrete implementation.

\textbf{Focus Point:} Combine abstraction with dependency inversion to maximize flexibility and testability.



\subsubsection{What Is Dynamic Dispatch?}

\textbf{Definition:} Runtime mechanism that selects which method implementation to invoke based on the actual object type, not the reference type.

\textbf{Why:} Enables late binding in polymorphism. Required when working with interfaces, abstract classes, or overridden methods.

\begin{lstlisting}[language=Java]
interface Shape { void draw(); }

class Circle implements Shape {
    public void draw() { System.out.println("Draw Circle"); }
}

Shape s = new Circle();
s.draw(); // invokes Circle.draw() at runtime
\end{lstlisting}

\textbf{Focus Point:} Only overridden instance methods use dynamic dispatch. Static methods and constructors are resolved at compile time.

\subsection{Class Relationships}

\subsubsection{Composition vs Inheritance}

\paragraph{Inheritance (is-a)}
Inheritance defines a strict hierarchical relationship between classes. A subclass inherits fields and methods from its superclass and can override or extend behavior.

\textbf{Use case:} when the subclass is a true specialization of the base class and follows the Liskov Substitution Principle.

\begin{lstlisting}[language=Java]
// Inheritance: Car is a type of Vehicle
class Vehicle {
    public void startEngine() {
        System.out.println("Engine started");
    }
}

class Car extends Vehicle {
    public void openTrunk() {
        System.out.println("Trunk opened");
    }
}
\end{lstlisting}

\textbf{Focus Point:} Inheritance couples the subclass tightly to the superclass. Changes in the base class may propagate unintended side effects to all subclasses.

\paragraph{Composition (has-a)}
Composition defines a relationship where one class contains another. Behavior is delegated to the contained instance rather than inherited.

\textbf{Use case:} when classes collaborate through defined interfaces, or when behavior needs to be injected, replaced, or mocked independently.

\begin{lstlisting}[language=Java]
// Composition: Car has an Engine
class Engine {
    public void start() {
        System.out.println("Engine started");
    }
}

class Car {
    private final Engine engine;

    public Car(Engine engine) {
        this.engine = engine;
    }

    public void startCar() {
        engine.start();
    }
}
\end{lstlisting}

\textbf{Focus Point:} Composition promotes low coupling and higher flexibility. Behavior can be composed at runtime and dependencies can be injected via interfaces.

\paragraph{Comparison Summary}
\begin{itemize}
  \item \textbf{Inheritance:} strong coupling, static hierarchy, may violate SRP or LSP.
  \item \textbf{Composition:} looser coupling, better encapsulation, easier testing and replacement.
\end{itemize}

\textbf{Best Practice:} Prefer composition unless inheritance is semantically correct and provides clear structural or behavioral reuse.

\subsubsection{Advantages and Disadvantages of Inheritance}

\paragraph{Advantages}

\begin{itemize}
  \item \textbf{Code Reuse:} Common logic can be implemented once in a base class and reused across multiple subclasses.
  \item \textbf{Hierarchical Modeling:} Natural fit for "is-a" relationships (e.g., \texttt{Dog is-an Animal}).
  \item \textbf{Polymorphism:} Enables treating different subclasses through a common superclass interface.
\end{itemize}

\paragraph{Disadvantages}

\begin{itemize}
  \item \textbf{Tight Coupling:} Subclasses depend heavily on base class behavior. Changes to the superclass can cascade and break subclasses.
  \item \textbf{Fragile Hierarchies:} Difficult to modify or extend safely. Violations of the Liskov Substitution Principle often occur.
  \item \textbf{Inheritance Breaks Encapsulation:} Subclasses may depend on implementation details of the superclass.
  \item \textbf{Limited Flexibility:} Single inheritance forces rigid hierarchy; hard to reuse behavior outside the chain.
\end{itemize}

\textbf{Focus Point:} Use inheritance when there is a clear and stable "is-a" relationship and shared behavior. Prefer composition for flexibility and lower coupling.

\subsubsection{Interface vs Abstract Class}

\paragraph{Interface}
Defines a behavioral contract without enforcing inheritance. Originally limited to method signatures, modern interfaces (Java 8+, Kotlin) support default methods.

\begin{lstlisting}[language=Java]
interface Animal {
    void speak();
    default void sleep() {
        System.out.println("Sleeping...");
    }
}
\end{lstlisting}

\textbf{Key Characteristics:}
\begin{itemize}
  \item No instance fields (stateless).
  \item Supports multiple inheritance.
  \item Cannot define constructors.
  \item Intended for capability declarations.
\end{itemize}

\paragraph{Abstract Class}
Provides a partially implemented base with optional abstract methods. Can define state and behavior.

\begin{lstlisting}[language=Java]
abstract class Animal {
    String name;

    abstract void speak();

    void eat() {
        System.out.println("Eating...");
    }
}
\end{lstlisting}

\textbf{Key Characteristics:}
\begin{itemize}
  \item Can maintain state and define constructors.
  \item Supports single inheritance.
  \item Intended for specialization in class hierarchies.
\end{itemize}

\paragraph{Comparison Table}

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Feature} & \textbf{Interface} & \textbf{Abstract Class} \\
\hline
Instance State           & x & v \\
Default Implementations  & x & v \\
Constructors             & x & v \\
Multiple Inheritance     & x & x \\
Inheritance Type         & Capability-based & Hierarchical \\
\hline
\end{tabular}
\end{center}

\textbf{Focus Point:} Use interfaces to define roles across unrelated types; use abstract classes to extract common logic from a class hierarchy.

\textbf{When to Use}
\begin{itemize}
  \item Use \textbf{interfaces} for multiple capabilities (e.g., \texttt{Runnable}, \texttt{Serializable}).
  \item Use \textbf{abstract classes} to share internal logic or fields across a specialized class family.
\end{itemize}

\subsection{OOP Behavior and Semantics}

\subsubsection{Difference Between Overriding and Overloading}

\paragraph{Overriding}
Redefines a superclass method in a subclass using the same signature. Enables \textbf{dynamic polymorphism}. Dispatch is determined at runtime.

\paragraph{Overloading}
Defines multiple methods with the same name but different parameter lists in the same class. Resolution is based on static types at compile time.

\begin{lstlisting}[language=Java]
// Overriding
class MyClass {
    @Override
    public String toString() { return "MyClass"; }
}

// Overloading
int add(int a, int b) { return a + b; }
double add(double a, double b) { return a + b; }
\end{lstlisting}

\textbf{Focus Point:} Overriding is about behavior replacement across a hierarchy; overloading is about convenience and readability.

\subsubsection{What Are Classes and Objects?}

\paragraph{Class}
A blueprint or template defining the structure and behavior of entities. Specifies fields, methods, and constructors.

\paragraph{Object}
A concrete instance of a class, allocated in memory, with its own state and behavior.

\begin{lstlisting}[language=Kotlin]
class Car(val model: String)

val myCar = Car("Tesla") // object of class Car
\end{lstlisting}

\textbf{Focus Point:} Classes define contracts; objects represent actual data in memory following those contracts.


\subsubsection{What Is Polymorphism? How Do You Use It?}

\textbf{What:} Polymorphism is the ability to treat instances of different classes through a shared interface or superclass, allowing method calls to be dynamically dispatched based on the actual object type.

\textbf{Why:} Polymorphism enables decoupled code by allowing logic to operate on abstractions rather than concrete implementations. This simplifies extension, substitution, and reuse.

\textbf{How:} Define a common interface or superclass, and let concrete classes implement or extend it. At runtime, the appropriate method implementation is resolved based on the actual object instance.

\begin{lstlisting}[language=Java]
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing a circle");
    }
}

class Square implements Shape {
    public void draw() {
        System.out.println("Drawing a square");
    }
}

List<Shape> shapes = List.of(new Circle(), new Square());
for (Shape s : shapes) {
    s.draw(); // dynamically resolved at runtime
}
\end{lstlisting}

\textbf{Focus Point:} Prefer programming to interfaces. Polymorphism decouples behavior from specific implementations, enabling easier testing, substitution, and extensibility.

\textbf{Deep Dive:} Under the hood, polymorphism relies on dynamic dispatch tables (v-tables) in languages like Java. The actual method to invoke is determined at runtime via the object's class metadata.





\section{Clean Code and Quality}

\subsection{What is Clean Code}
Writing \textbf{Clean Code} means producing code that is easy to read, understand, maintain, and modify. It’s not enough for the code to “work”: it should also clearly communicate \emph{what} it does and \emph{why} it does it.

Good code is written for both machines and humans: the second reader of your code is always you (or someone else) a few weeks later.

\subsubsection{Characteristics of Clean Code}
\begin{itemize}
  \item \textbf{Readable and clear:} structure and meaning should be immediately obvious, with no unnecessary comments.
  \item \textbf{Free of duplication:} duplicated code is hard to maintain. A change requires multiple edits.
  \item \textbf{Logically organized:} related concepts should be close together. Modules should be separated by responsibility.
  \item \textbf{Explicit and meaningful names:} variables, classes, and functions should clearly describe their purpose.
  \item \textbf{Small, cohesive functions:} each function should do one thing and do it well, ideally in fewer than 20 lines.
\end{itemize}

\subsubsection{Example of Bad Code}
\begin{lstlisting}[language=Java]
public class InvoiceProcessor {
    public void f1() {
        double x = subtotal * 0.2;
        double y = subtotal + x;
        System.out.println(y);
    }
}
\end{lstlisting}
This method is unclear: the name `f1` means nothing, and variables `x` and `y` lack any meaning.

\subsubsection{Example of Clean Code}
\begin{lstlisting}[language=Java]
public class InvoiceProcessor {
    private static final double TAX_RATE = 0.2;

    public void calculateTotalWithTax(double subtotal) {
        double tax = subtotal * TAX_RATE;
        double total = subtotal + tax;
        System.out.println("Total with tax: " + total);
    }
}
\end{lstlisting}

Here:
\begin{itemize}
  \item the method name `calculateTotalWithTax` explains what it does;
  \item variables `tax` and `total` are clear;
  \item `TAX\_RATE` is a clearly named constant;
  \item the method is short and has a single responsibility.
\end{itemize}

\subsubsection{Guiding Principles}
\begin{itemize}
  \item \textbf{If something is hard to name, it may be too complex.}
  \item \textbf{Write code as if the next person to read it is a psychopath who knows where you live.}
  \item \textbf{Don’t leave your thoughts in the code — make them explicit.}
\end{itemize}

\subsection{Clean Code Principles}

\subsubsection{SRP – Single Responsibility Principle}
Each class or function should have a single responsibility — meaning \textbf{only one reason to change}.

\begin{lstlisting}[language=Java]
// SRP violation
class Report {
    void generate() { /* generate content */ }
    void print() { /* print */ }
    void saveToFile() { /* save to disk */ }
}
\end{lstlisting}

This code mixes three distinct responsibilities: generation, printing, and saving. Splitting them increases cohesion and simplifies maintenance.

\subsubsection{DRY – Don't Repeat Yourself}
\textbf{Don’t repeat code or logic.} Duplication makes maintenance harder: if you change something in one place, you must remember to change it everywhere else.

\begin{lstlisting}[language=Java]
// Example of duplication
double applyDiscount(double price) {
    return price - (price * 0.1);
}

double calculateTotal(double subtotal) {
    return subtotal - (subtotal * 0.1);
}
\end{lstlisting}

Better to extract the common logic:

\begin{lstlisting}[language=Java]
double applyDiscount(double amount) {
    return amount * 0.9;
}
\end{lstlisting}

\subsubsection{KISS – Keep It Simple, Stupid}
Code should be easy to understand. Avoid over-engineering and complex solutions when a simpler one will do.

\begin{itemize}
  \item Prefer simple structures over deep abstract class hierarchies.
  \item Avoid premature complexity.
\end{itemize}

\textbf{Golden rule:} if a junior developer doesn’t understand your code, it’s probably too complex.

\subsubsection{YAGNI – You Ain’t Gonna Need It}
Don’t write code for features you \textbf{might need one day}. Focus only on what’s needed now.

\begin{itemize}
  \item Reduce dead or unused code.
  \item Stay focused on current requirements.
\end{itemize}

\begin{lstlisting}[language=Java]
// Premature code
public void exportToXML() {
    // TODO: not required, never used
}
\end{lstlisting}

\subsubsection{Small, well-named functions}
Each function should be:
\begin{itemize}
  \item short (ideally under 20 lines),
  \item have a single purpose,
  \item and have a name that clearly describes what it does.
\end{itemize}

\begin{lstlisting}[language=Java]
// Avoid names like:
void f1() { ... }

// Use descriptive names:
void calculateInvoiceTotalWithTax() { ... }
\end{lstlisting}

\subsubsection{Active and constructive code reviews}
Clean Code is also built through teamwork. Code reviews should be:
\begin{itemize}
  \item frequent and regular,
  \item focused on readability, logic, and security,
  \item accompanied by constructive feedback,
  \item an opportunity for mutual learning.
\end{itemize}

\subsection{Refactoring and Code Smells}

\textbf{Refactoring} is the process of improving the internal structure of code without changing its external behavior. It aims to enhance readability, maintainability, and extensibility. Common refactoring techniques include:

\begin{itemize}
  \item \textbf{Extract Method:} Splitting large functions into smaller, focused methods to improve readability and reusability.
  \item \textbf{Rename Variable or Method:} Choosing descriptive names to make the purpose of code clearer.
  \item \textbf{Remove Duplication:} Identifying repeated logic and consolidating it into a shared method or utility.
  \item \textbf{Split Responsibilities:} Moving unrelated logic into separate classes or layers to follow the Single Responsibility Principle.
\end{itemize}

\textbf{Code smells} are symptoms of poor design or implementation that may hinder maintainability. While not bugs, they often indicate areas that need refactoring. Common code smells include:

\begin{itemize}
  \item \textbf{Long Method:} A method that tries to do too much and becomes hard to read or test.
  \item \textbf{God Class:} A class with too many responsibilities, violating the SRP.
  \item \textbf{Dead Code:} Unused variables, parameters, or functions that add noise to the codebase.
  \item \textbf{Circular Dependency:} Modules that depend on each other directly or indirectly, making the system fragile and harder to maintain.
\end{itemize}

These issues are typically identified through code reviews, static analysis tools (like SonarQube or Lint), and continuous refactoring as part of a clean code practice.

\subsection{Code Reviews}

Code reviews are a collaborative process where developers examine each other's code before it is merged into the main codebase. The goal is to maintain high code quality, ensure consistency, and catch potential issues early.

Effective code reviews focus on:
\begin{itemize}
  \item \textbf{Correctness:} Ensuring the code does what it's supposed to do without introducing bugs.
  \item \textbf{Readability:} Making sure the code is easy to understand and maintain.
  \item \textbf{Style and Consistency:} Verifying adherence to coding standards and team conventions.
  \item \textbf{Design:} Evaluating the structure, modularity, and reuse of code.
  \item \textbf{Test Coverage:} Confirming that the code is well-tested and does not reduce test quality.
\end{itemize}

Code reviews are also an opportunity for knowledge sharing and team learning. Constructive feedback, asking questions instead of imposing changes, and praising good solutions are key to building a healthy review culture. Tools like GitHub, GitLab, and Bitbucket facilitate code reviews through pull requests and inline commenting.

\subsection{How to Document Code}

Documentation should complement readable code, not replace it. Key practices:

\begin{itemize}
  \item Prefer \textbf{self-explanatory naming} over comments
  \item Use \texttt{KDoc} (or equivalent) for public APIs, classes, and methods
  \item Write comments to explain \textit{why}, not \textit{what}
  \item Keep \texttt{README.md} files updated for each major module
  \item Avoid redundant or outdated comments
\end{itemize}


\section{Testing and CI/CD}

\subsection{Unit Tests and TDD}

\textbf{What:} Unit tests verify individual units of logic (functions, classes) in isolation. TDD (Test-Driven Development) is a methodology where tests are written before implementation.

\textbf{Why:} Ensures correctness, supports safe refactoring, and improves design through feedback.

\textbf{How:} The \textit{Red-Green-Refactor} loop:

\begin{itemize}
  \item \textbf{Red:} Write a failing test that expresses the expected behavior.
  \item \textbf{Green:} Implement the minimal logic required to make the test pass.
  \item \textbf{Refactor:} Clean up the implementation without breaking the test.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
// Red: Failing test
@Test
fun shouldReturnTrueForEven() {
    assertTrue(isEven(4))
}

// Green: Minimal implementation
fun isEven(n: Int) = n % 2 == 0
\end{lstlisting}

\textbf{Focus Point:} Unit tests must be deterministic, fast, isolated from I/O and shared state.

\subsection{CI/CD Concepts and Tools}

\textbf{What:}
\begin{itemize}
  \item \textbf{Continuous Integration (CI):} Automatically build and test code on every change.
  \item \textbf{Continuous Delivery (CD):} Automatically prepare artifacts for deployment.
  \item \textbf{Continuous Deployment:} Automatically release to production after successful validation.
\end{itemize}

\textbf{Why:} Prevent integration issues, detect regressions early, reduce manual errors in deployment.

\textbf{How:} Define pipelines as code. Trigger on git events (e.g., push, PR). Stages typically include:

\begin{itemize}
  \item \textbf{Build:} Compile, package, or create Docker images.
  \item \textbf{Test:} Run unit tests, static analysis, linting.
  \item \textbf{Deploy:} Publish to staging or production environments.
\end{itemize}

\textbf{Tools:}
\begin{itemize}
  \item \texttt{GitHub Actions}: Native CI/CD with YAML workflows.
  \item \texttt{GitLab CI}: Integrated pipelines with Docker support.
  \item \texttt{Jenkins}: Scriptable and extensible CI server.
  \item \texttt{CircleCI}: Fast pipelines with parallelism and caching.
\end{itemize}

\textbf{Focus Point:} Always treat your pipeline as part of the codebase. Use versioned, reproducible builds.


\section{Architecture and Patterns}

\subsection{Design Patterns}

\textbf{Design patterns} are reusable, abstract solutions to common design problems. They improve structure, readability, and testability by enforcing proven architectural decisions.

The following patterns are essential in modern object-oriented development.

\subsubsection{Singleton}

Ensures that a class has only one instance and provides a global access point to it.

\textbf{When to use:}
\begin{itemize}
  \item Central configuration or logging.
  \item Shared context or resource access.
\end{itemize}

\begin{lstlisting}[language=Java]
public class Configuration {
    private static Configuration instance;

    private Configuration() {}

    public static Configuration getInstance() {
        if (instance == null) {
            instance = new Configuration();
        }
        return instance;
    }
}
\end{lstlisting}

\textbf{Focus Point:} Ensure thread-safety if used in multithreaded environments.

\subsubsection{Factory Method}

Provides an interface for creating objects while deferring instantiation to subclasses.

\textbf{When to use:}
\begin{itemize}
  \item Object creation logic is complex or dynamic.
  \item Subclasses must decide what object to create.
\end{itemize}

\begin{lstlisting}[language=Java]
interface Notification {
    void send();
}

class EmailNotification implements Notification {
    public void send() { System.out.println("Email sent"); }
}

class SMSNotification implements Notification {
    public void send() { System.out.println("SMS sent"); }
}

class NotificationFactory {
    public static Notification create(String type) {
        return switch (type) {
            case "EMAIL" -> new EmailNotification();
            case "SMS" -> new SMSNotification();
            default -> throw new IllegalArgumentException();
        };
    }
}
\end{lstlisting}

\subsubsection{Observer}

Defines a one-to-many relationship so that when one object changes, all its dependents are notified.

\textbf{When to use:}
\begin{itemize}
  \item Event-driven systems.
  \item Reactive UI architectures.
\end{itemize}

\begin{lstlisting}[language=Java]
interface Observer {
    void update(String data);
}

class ConcreteObserver implements Observer {
    public void update(String data) {
        System.out.println("Received: " + data);
    }
}

class Subject {
    private List<Observer> observers = new ArrayList<>();
    void register(Observer o) { observers.add(o); }
    void notifyObservers(String data) {
        for (Observer o : observers) o.update(data);
    }
}
\end{lstlisting}

\subsubsection{Decorator}

Adds responsibilities to an object dynamically, without modifying its class.

\textbf{When to use:}
\begin{itemize}
  \item Flexible, optional features.
  \item Avoiding subclass explosion.
\end{itemize}

\begin{lstlisting}[language=Java]
interface Notifier {
    void send();
}

class BasicNotifier implements Notifier {
    public void send() {
        System.out.println("Base notification");
    }
}

class SMSDecorator implements Notifier {
    private Notifier base;
    SMSDecorator(Notifier base) { this.base = base; }
    public void send() {
        base.send();
        System.out.println("Also sending SMS");
    }
}
\end{lstlisting}

\textbf{Focus Point:} Decorators respect the Open/Closed Principle.

\subsubsection{Strategy}

Encapsulates a family of algorithms, making them interchangeable at runtime.

\textbf{When to use:}
\begin{itemize}
  \item Replace switch statements with dynamic behavior.
  \item Separate policy from implementation.
\end{itemize}

\begin{lstlisting}[language=Java]
interface PaymentStrategy {
    void pay(int amount);
}

class CreditCardPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid with credit card: " + amount);
    }
}

class PayPalPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid with PayPal: " + amount);
    }
}

class CheckoutContext {
    private PaymentStrategy strategy;
    CheckoutContext(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    void process(int amount) {
        strategy.pay(amount);
    }
}
\end{lstlisting}

\textbf{Focus Point:} Strategy is an OCP enabler and promotes composition.

\subsubsection{Builder}

Separates the construction of a complex object from its representation.

\textbf{When to use:}
\begin{itemize}
  \item Multiple constructor overloads.
  \item Immutable object configuration.
\end{itemize}

\begin{lstlisting}[language=Java]
class User {
    private final String name;
    private final int age;

    private User(Builder b) {
        this.name = b.name;
        this.age = b.age;
    }

    static class Builder {
        private String name;
        private int age;

        Builder name(String name) {
            this.name = name; return this;
        }

        Builder age(int age) {
            this.age = age; return this;
        }

        User build() {
            return new User(this);
        }
    }
}
\end{lstlisting}

\textbf{Focus Point:} Builder is common in APIs (e.g., Retrofit, AlertDialog).

\subsubsection{Adapter}

Converts the interface of a class into another expected by clients.

\textbf{When to use:}
\begin{itemize}
  \item Legacy or third-party integration.
  \item Interface mismatch between layers.
\end{itemize}

\begin{lstlisting}[language=Java]
interface MediaPlayer {
    void play(String filename);
}

class VLCPlayer {
    void playVLC(String file) {
        System.out.println("Playing VLC: " + file);
    }
}

class VLCAdapter implements MediaPlayer {
    private VLCPlayer player = new VLCPlayer();
    public void play(String filename) {
        player.playVLC(filename);
    }
}
\end{lstlisting}

\textbf{Focus Point:} Adapter supports reusability without modifying source code.

\subsubsection{Command}

Encapsulates a request as an object, allowing parameterization, queuing, and undo.

\textbf{When to use:}
\begin{itemize}
  \item Deferred execution (queues, schedulers).
  \item Undo/redo systems.
\end{itemize}

\begin{lstlisting}[language=Java]
interface Command {
    void execute();
}

class LightOnCommand implements Command {
    public void execute() {
        System.out.println("Light ON");
    }
}

class RemoteControl {
    private Command command;
    void setCommand(Command c) { command = c; }
    void pressButton() { command.execute(); }
}
\end{lstlisting}

\textbf{Focus Point:} Commands decouple invoker from executor and enable action history.


\subsection{Architectural Patterns}

\textbf{Architectural patterns} are high-level templates that define how major components of an application interact. They target the structure of systems, focusing on separation of concerns, state management, testability, and scalability.

\textbf{Focus Point:} Architectural patterns operate at a broader level than GoF design patterns. They govern system-level structure rather than class-level behavior.

\subsubsection{MVC - Model View Controller}

\textbf{Purpose:} Separate the user interface from business logic and data.

\begin{itemize}
  \item \textbf{Model:} application data and business rules.
  \item \textbf{View:} displays data and receives user interaction.
  \item \textbf{Controller:} handles input and mediates between View and Model.
\end{itemize}

\textbf{Pros:}
\begin{itemize}
  \item Strong separation of concerns.
  \item Simplifies UI logic testing when controller is independent.
\end{itemize}

\textbf{Cons:}
\begin{itemize}
  \item Controller logic often becomes bloated.
  \item Passive views can shift logic back into the View.
\end{itemize}

\textbf{Focus Point:} In Android, MVC often degrades into “Massive Activity” where the Activity improperly acts as Controller, View, and sometimes Model.

\subsubsection{MVP - Model View Presenter}

\textbf{Purpose:} Extract presentation logic from the View for better testability.

\begin{itemize}
  \item \textbf{Model:} data + business rules.
  \item \textbf{View:} interface with only display logic, passive.
  \item \textbf{Presenter:} handles UI events and updates both Model and View.
\end{itemize}

\textbf{Pros:}
\begin{itemize}
  \item High testability: Presenter can be unit tested in isolation.
  \item Clear contracts via interfaces between View and Presenter.
\end{itemize}

\textbf{Cons:}
\begin{itemize}
  \item Requires more boilerplate (View interfaces, binding).
  \item Presenter can become large and hard to maintain.
\end{itemize}

\textbf{Focus Point:} Use dependency injection to test Presenters without Android framework dependencies.

\subsubsection{MVVM - Model View ViewModel}

\textbf{Purpose:} Separate UI state from UI rendering via ViewModel.

\begin{itemize}
  \item \textbf{Model:} domain logic and data.
  \item \textbf{View:} XML layout or composable displaying UI.
  \item \textbf{ViewModel:} exposes observable UI state and events.
\end{itemize}

\textbf{Pros:}
\begin{itemize}
  \item State-driven UI via LiveData, Flow, or State.
  \item Testable ViewModel, no direct Android dependencies.
\end{itemize}

\textbf{Cons:}
\begin{itemize}
  \item Two-way data binding may obscure state ownership.
  \item ViewModel lifecycle must be managed properly.
\end{itemize}

\textbf{Focus Point:} Use one-way data flow (`state -> view -> event -> state`) to reduce UI bugs.

\subsubsection{MVI - Model View Intent}

\textbf{Purpose:} Enforce unidirectional state flow with immutability and clear transitions.

\begin{itemize}
  \item \textbf{Model:} full app state (immutable).
  \item \textbf{View:} reacts to state, emits intents.
  \item \textbf{Intent:} describes user actions or system events.
\end{itemize}

\textbf{Pros:}
\begin{itemize}
  \item Immutable state makes bugs reproducible and debugging easier.
  \item Reducers clarify how state transitions occur.
\end{itemize}

\textbf{Cons:}
\begin{itemize}
  \item Boilerplate-heavy: actions, reducers, state classes.
  \item Learning curve is high without tooling support.
\end{itemize}

\textbf{Deep Dive:} In MVI, the flow is:
\begin{lstlisting}[language=Kotlin]
// Pseudocode
fun handle(intent): PartialState
fun reduce(old: State, partial: PartialState): State
\end{lstlisting}
This makes UI predictable and easily testable.

\subsubsection{Conclusion}

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Pattern} & \textbf{Pros} & \textbf{Cons} & \textbf{Best For} \\\hline
MVC & Clear separation & Ambiguous controller & Simple UIs / Web \\\hline
MVP & Testable, decoupled UI & Presenter complexity & Legacy Android UIs \\\hline
MVVM & Reactive & State tracing is complex & Modern Android (Jetpack) \\\hline
MVI & Predictable flow & Boilerplate, complexity & Reactive + scalable apps \\\hline
\end{tabular}
\end{center}

\textbf{Focus Point:} MVVM is the current baseline for Android Jetpack architecture. MVI is often layered on top using Redux-like reducers and state streams (e.g., Kotlin Flow + StateFlow).

\subsection{Reactive Programming}

Reactive programming is a declarative paradigm for modeling data and events as asynchronous streams over time. A reactive system reacts to emitted values, transformations, and propagations, allowing fine-grained control over time-dependent data flows.

\subsubsection{What:}
A program is reactive when its logic is defined by the propagation of changes across event/data streams. Observers subscribe to streams and get notified when new data is emitted or when an error/completion occurs.

\subsubsection{Why:}
It simplifies the management of:
\begin{itemize}
  \item asynchronous operations (e.g., network, I/O),
  \item event-based logic (e.g., UI updates),
  \item chaining transformations without nesting or state management,
  \item concurrency and backpressure handling.
\end{itemize}

\subsubsection{How It Works:}
Reactive programming builds on the concepts of:
\begin{itemize}
  \item \textbf{Observable / Flowable / Flow:} source of data over time.
  \item \textbf{Operator:} function that transforms, filters, merges, or delays emissions.
  \item \textbf{Observer / Subscriber / Collector:} consumer that reacts to emissions.
\end{itemize}

In Kotlin, reactive programming is commonly implemented using \texttt{Flow} from Kotlinx Coroutines or with \texttt{RxJava}'s \texttt{Observable}, \texttt{Flowable}.

\begin{lstlisting}[language=Kotlin]
// Flow example
fun numbers(): Flow<Int> = flow {
    for (i in 1..3) {
        emit(i)
        delay(100)
    }
}

suspend fun main() {
    numbers()
        .map { it * 2 }
        .collect { println(it) }
}
\end{lstlisting}

\texttt{Flow} is cold and cancellable, runs in coroutine context, and supports structured concurrency.

\textbf{Focus Point:} Reactive programming is not multithreading. It’s about reacting to changes over time — scheduling is orthogonal and controlled via operators like \texttt{flowOn}, \texttt{subscribeOn}, or \texttt{observeOn}.

\begin{lstlisting}[language=Kotlin]
// RxJava example
Observable.just(1, 2, 3)
    .map { it * 2 }
    .subscribe { println(it) }
\end{lstlisting}

\subsubsection{Backpressure (RxJava only):}
If producers emit faster than consumers can consume, backpressure strategies (\texttt{onBackpressureBuffer}, \texttt{onBackpressureDrop}) apply. \texttt{Flow} in coroutines handles this natively with suspending emissions.

\textbf{Deep Dive: Reactive vs Imperative}

Imperative code:
\begin{lstlisting}[language=Kotlin]
val result = fetchData()
process(result)
\end{lstlisting}

Reactive code:
\begin{lstlisting}[language=Kotlin]
fetchDataFlow()
  .map { process(it) }
  .collect()
\end{lstlisting}

The second model enables cancellation, chaining, retries, and concurrency with less boilerplate.

\textbf{Focus Point:} Always manage lifecycle and cancellation in reactive code. In Android, use \texttt{lifecycleScope} or \texttt{viewModelScope} for coroutines and \texttt{CompositeDisposable} for RxJava.


\subsection{Dependency Injection}

Dependency Injection (DI) is a design technique where dependencies are provided externally, rather than instantiated inside the class. It reduces coupling and improves testability, configurability, and adherence to the Dependency Inversion Principle (DIP).

\subsubsection{Concept}

A \textit{dependency} is any object a class requires to function. Injecting it means passing it from the outside.

\textbf{Without DI:}
\begin{lstlisting}[language=Java]
class UserService {
    private final UserRepository repo = new UserRepository();
}
\end{lstlisting}

\textbf{With DI:}
\begin{lstlisting}[language=Java]
class UserService {
    private final UserRepository repo;
    public UserService(UserRepository repo) {
        this.repo = repo;
    }
}
\end{lstlisting}

\textbf{Focus Point:} Instantiating dependencies inside a class hides implementation details and makes testing difficult. Injection enforces clear contracts and enables mocking.

\subsubsection{Benefits}

\begin{itemize}
  \item \textbf{Testability:} allows mocking dependencies.
  \item \textbf{Flexibility:} implementations can be swapped without changing the class.
  \item \textbf{Decoupling:} reduces direct dependencies between components.
  \item \textbf{Modularity:} promotes single-responsibility and easier refactoring.
\end{itemize}

\textbf{Focus Point:} DI is not a framework feature — it's a design choice. Frameworks simplify it, but manual injection still provides all architectural benefits.

\subsubsection{Injection Methods}

\begin{itemize}
  \item \textbf{Constructor Injection:} safest and preferred. Immutable, enforces complete dependencies at object creation.
  \item \textbf{Field Injection:} easy but hides required dependencies. Not suitable for unit testing.
  \item \textbf{Setter Injection:} useful for optional dependencies, but allows incomplete state.
\end{itemize}

\textbf{Focus Point:} Use constructor injection for mandatory dependencies. Reserve setter injection only for truly optional cases.

\subsubsection{Common DI Frameworks}

\begin{itemize}
  \item \textbf{Dagger:} compile-time DI, efficient and type-safe.
  \item \textbf{Hilt:} abstraction over Dagger, lifecycle-aware.
  \item \textbf{Spring (Java), Koin (Kotlin):} used in backend and JVM applications.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
// Hilt example
@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    @Inject lateinit var repo: UserRepository
}
\end{lstlisting}

\textbf{Deep Dive: Dagger and Hilt Internals}

Dagger generates code to build dependency graphs at compile-time via annotation processors. Each \texttt{@Module} defines providers. Each \texttt{@Component} acts as an entry point to retrieve dependencies. Hilt wraps this by auto-generating components scoped to Android lifecycles (e.g., \texttt{@ActivityRetainedScoped}, \texttt{@Singleton}).

\textbf{Focus Point:} DI scope mismatch (e.g., injecting a singleton into a scoped component) leads to memory leaks or multiple unintended instances. Always align scopes properly.

\subsection{Clean Architecture: Structure, Purpose, and Data Flow}

\subsubsection{Overview}

\textbf{Clean Architecture} is a software design pattern introduced by \textbf{Robert C. Martin} (Uncle Bob) that aims to separate concerns and create maintainable, testable, and scalable systems.  
Its key principle is: \textbf{dependencies must always point inward} — toward the domain and business logic.

\subsubsection{Goals of Clean Architecture}
\begin{itemize}
  \item \textbf{Independence from frameworks:} the business logic does not depend on specific technologies.
  \item \textbf{Testability:} core logic can be tested in isolation.
  \item \textbf{Modularity and separation of concerns.}
  \item \textbf{Flexibility:} infrastructure (e.g., database, UI) can change without affecting business rules.
\end{itemize}

\textbf{Focus Point:} Frameworks are considered delivery mechanisms. Your app should work without them. Domain logic should compile without Android SDK, Retrofit, or Room.

\subsubsection{Layered Structure}

Clean Architecture is often represented as concentric circles, where each inner layer is more abstract and stable, and each outer layer depends only on the layer inside it.

\begin{center}
\begin{tabular}{|l|p{9cm}|}
\hline
\textbf{Layer} & \textbf{Responsibilities} \\
\hline
\textbf{Domain} & 
Contains core business rules: entities and repository interfaces. It does not depend on any other layer. \\
\hline
\textbf{Application / Use Cases} & 
Orchestrates domain logic for specific business operations (e.g., \texttt{LoginUseCase}). Depends only on domain abstractions. \\
\hline
\textbf{Interface Adapters} & 
Adapts data between use cases and the external world. Contains ViewModels, DTO mappers, and presenters. \\
\hline
\textbf{Data Layer} & 
Implements the domain interfaces (e.g., \texttt{UserRepositoryImpl}), and accesses APIs or databases using tools like Retrofit or Room. \\
\hline
\textbf{Frameworks / Drivers} & 
Contains the actual frameworks and technologies: Android SDK, UI, web servers, DB engines. Injected into outer layers. \\
\hline
\end{tabular}
\end{center}

\subsubsection{Dependency Direction}

\textbf{Only inward dependencies are allowed.} That means:

\begin{itemize}
  \item The UI layer depends on Use Cases.
  \item Use Cases depend on Repository interfaces from the Domain.
  \item The Data layer implements those interfaces.
  \item The Domain layer depends on nothing.
\end{itemize}

\textbf{Focus Point:} Inversion of control must be explicit and respected. The Domain cannot reference anything outside itself — not Retrofit, not ViewModel, not Android.

\subsubsection{Data Flow Example}

\vspace{0.5em}
\noindent\textbf{Scenario: Login Flow}
\begin{enumerate}
  \item \texttt{LoginViewModel} calls the \texttt{LoginUseCase}.
  \item The \texttt{LoginUseCase} calls the \texttt{AuthRepository} interface from the Domain.
  \item Hilt/Dagger provides the concrete implementation: \texttt{AuthRepositoryImpl} from the Data layer.
  \item \texttt{AuthRepositoryImpl} performs an API call using Retrofit.
  \item The API returns a \texttt{UserDto}, which is mapped to a \texttt{User} entity.
  \item The \texttt{User} is returned through the use case to the ViewModel.
\end{enumerate}

\subsubsection{Project Structure Example (Android)}

\begin{verbatim}
- domain/
    - model/
    - repository/
    - usecase/
- data/
    - repositoryImpl/
    - api/
    - db/
    - dto/
    - mapper/
- presentation/
    - viewmodel/
    - ui/
    - event/
\end{verbatim}

\subsubsection{Code Example}

\textbf{Domain Layer}
\begin{lstlisting}[language=Kotlin]
// AuthRepository.kt
interface AuthRepository {
    suspend fun login(username: String, password: String): Result<User>
}

// LoginUseCase.kt
class LoginUseCase(private val repository: AuthRepository) {
    suspend fun execute(username: String, password: String): Result<User> {
        return repository.login(username, password)
    }
}
\end{lstlisting}

\textbf{Data Layer}
\begin{lstlisting}[language=Kotlin]
// AuthRepositoryImpl.kt
class AuthRepositoryImpl(private val api: AuthApi) : AuthRepository {
    override suspend fun login(username: String, password: String): Result<User> {
        val response = api.login(username, password)
        return mapDtoToUser(response)
    }
}
\end{lstlisting}

\textbf{Presentation Layer}
\begin{lstlisting}[language=Kotlin]
// LoginViewModel.kt
@HiltViewModel
class LoginViewModel @Inject constructor(
    private val loginUseCase: LoginUseCase
) : ViewModel() {

    val loginState = MutableLiveData<Result<User>>()

    fun login(username: String, password: String) {
        viewModelScope.launch {
            loginState.value = loginUseCase.execute(username, password)
        }
    }
}
\end{lstlisting}

\textbf{Focus Point:} ViewModels, Retrofit, and mappers should not leak into use cases or domain. Validate separation by compiling each layer in isolation.

\subsubsection{Deep Dive: Mapping Between Layers}

DTOs from APIs or databases must be converted to domain models via mappers. These conversions isolate external contracts from core logic.

\begin{lstlisting}[language=Kotlin]
// Mapper.kt
fun UserDto.toDomain(): User = User(id, name)
\end{lstlisting}

\textbf{Focus Point:} Mappers prevent tight coupling between domain and external models. Domain should never import \texttt{dto} or \texttt{entity} classes from other layers.

\subsubsection{Benefits Summary}

\begin{itemize}
  \item \textbf{Testability:} Each layer can be tested independently.
  \item \textbf{Flexibility:} Easy to swap or mock infrastructure components.
  \item \textbf{Maintainability:} Clear separation of concerns.
  \item \textbf{Scalability:} New features can be added with minimal side effects.
\end{itemize}

\subsubsection{When to Use It}

\begin{itemize}
  \item For medium to large-scale applications.
  \item When business logic is complex or likely to evolve.
  \item In multi-developer teams where separation of responsibilities is critical.
\end{itemize}

\subsubsection{Potential Drawbacks}

\begin{itemize}
  \item More boilerplate and setup time.
  \item Requires architectural discipline and upfront design.
  \item Might be excessive for very simple or short-lived projects.
\end{itemize}

\subsection{Modular Architecture}

Modular architecture divides a codebase into independently buildable and testable modules. Each module encapsulates a specific responsibility and communicates with others via well-defined interfaces.

\subsubsection{Why Modularize}

\paragraph{Faster Builds}
Modules are compiled independently. Only the modified modules and their dependents are recompiled.

\textbf{Focus Point:} Gradle caching and parallelization are maximized when modules are cleanly separated with no cyclic dependencies.

\paragraph{Separation of Responsibilities}
Modules define strict boundaries around functionality (e.g., \texttt{auth}, \texttt{networking}). This enforces the Single Responsibility Principle across the entire app architecture.

\paragraph{Maintainability}
Each module can be refactored or debugged in isolation. Internal details remain hidden unless explicitly exposed.

\textbf{Focus Point:} Use visibility modifiers (e.g., \texttt{internal}) and avoid leaking internal APIs via public interfaces.

\paragraph{Testability and Reusability}
Modules can be unit tested independently, without bootstrapping the full application. They can also be reused across different apps or product flavors.

\begin{itemize}
  \item Example reusable modules: \texttt{lib-network}, \texttt{lib-database}, \texttt{lib-logger}.
\end{itemize}

\subsubsection{Example Structure}

\begin{itemize}
  \item \texttt{core}: logging, error handling, design system, constants
  \item \texttt{network}: Retrofit setup, interceptors, response mappers
  \item \texttt{auth}: login, registration, session manager
  \item \texttt{profile}: user profile screen and business logic
  \item \texttt{ui}: reusable UI components (buttons, dialogs)
  \item \texttt{app}: navigation, dependency graph, entry point
\end{itemize}

\subsubsection{Android-Specific Patterns}

\paragraph{Feature Modules}
Each feature (e.g., authentication, onboarding, settings) lives in its own module.

\begin{itemize}
  \item \texttt{feature-auth}
  \item \texttt{feature-profile}
  \item \texttt{feature-settings}
\end{itemize}

\paragraph{Library Modules}
Shared utilities and infrastructure are placed in libraries.

\begin{itemize}
  \item \texttt{lib-network}
  \item \texttt{lib-database}
  \item \texttt{lib-ui}
\end{itemize}

\paragraph{App Module}
The app module composes all modules. It sets up Hilt bindings, navigation graph, and application-wide configuration.

\textbf{Focus Point:} The app module should be as thin as possible. All logic should be delegated to features or libraries.

\subsubsection{Deep Dive: Dependency Management Between Modules}

Avoid bidirectional dependencies between modules. Use interfaces to decouple feature-to-feature communication.

\begin{lstlisting}[language=Kotlin]
// In lib-auth-api module
interface AuthNavigator {
    fun openLogin()
}

// In feature-auth module
class AuthNavigatorImpl : AuthNavigator {
    override fun openLogin() { /* startActivity(...) */ }
}
\end{lstlisting}

\textbf{Focus Point:} Use a separate `*-api` module to expose contracts, and bind implementations via DI.

\subsubsection{Build Optimization Tips}

\begin{itemize}
  \item Use \texttt{buildSrc} or convention plugins to avoid duplication across Gradle files.
  \item Disable unnecessary transitive dependencies using \texttt{api} vs \texttt{implementation}.
  \item Split annotation processors and kapt-heavy modules to reduce rebuild scope.
\end{itemize}

\subsubsection{When to Modularize}

\begin{itemize}
  \item When the project has multiple developers or teams.
  \item When builds are slow and scaling is needed.
  \item When features need independent testing or reuse.
\end{itemize}

\textbf{Focus Point:} Modularization adds maintenance overhead. Apply it only where boundaries are clear and justified.

\subsection{Structuring a Large-Scale Project}

Project structure impacts build speed, maintainability, and team scalability. A well-organized codebase enforces boundaries, reduces conflicts, and improves onboarding.

\subsubsection{Modularization Strategy}

Divide the codebase into multiple Gradle modules, grouped either:

\paragraph{Vertically (Feature-Based)}

Each business feature is isolated in its own module.

\begin{itemize}
  \item \texttt{feature-auth}
  \item \texttt{feature-profile}
  \item \texttt{feature-settings}
\end{itemize}

\paragraph{Horizontally (Layer-Based)}

Shared infrastructure is extracted into technical layers.

\begin{itemize}
  \item \texttt{core-ui}
  \item \texttt{core-network}
  \item \texttt{core-database}
\end{itemize}

\textbf{Focus Point:} Avoid cyclic dependencies. Define clear directional dependencies (e.g., UI → Domain → Data).

\subsubsection{Layered Architecture}

Each module can be internally structured into layers:

\begin{itemize}
  \item \textbf{Presentation:} UI controllers, ViewModels, navigation
  \item \textbf{Domain:} Use cases, business logic, interfaces
  \item \textbf{Data:} Repositories, DTOs, API clients, databases
\end{itemize}

\textbf{Focus Point:} Only the domain layer defines interfaces. Data layer implements them. Presentation uses use cases, not repositories directly.

\subsubsection{Naming Conventions}

Consistent, descriptive names improve readability and discoverability.

\begin{itemize}
  \item Use action-based naming for use cases: \texttt{GetUserProfileUseCase}
  \item Suffix interfaces with \texttt{Repository}, \texttt{Mapper}, \texttt{Navigator}
  \item Align DTO, entity, and UI model names: \texttt{UserDto}, \texttt{User}, \texttt{UserUiModel}
\end{itemize}

\textbf{Focus Point:} Avoid overloading generic names like \texttt{Manager}, \texttt{Helper}, \texttt{Service} unless semantically justified.

\subsubsection{Cross-Cutting Concerns}

Manage system-wide responsibilities centrally:

\begin{itemize}
  \item \textbf{Logging:} inject a common logging abstraction
  \item \textbf{Error handling:} define unified exception types and mappers
  \item \textbf{Testing:} shared test utilities and mock implementations
  \item \textbf{Documentation:} KDoc + per-module \texttt{README.md}
\end{itemize}

\textbf{Focus Point:} Define shared contracts in a \texttt{lib-common} or \texttt{core-contracts} module. This avoids leaking internal dependencies between features.

\subsubsection{Deep Dive: Navigating a Feature Module}

A single feature module (e.g., \texttt{feature-auth}) should contain:

\begin{verbatim}
- presentation/
    - LoginFragment.kt
    - LoginViewModel.kt
- domain/
    - LoginUseCase.kt
- data/
    - AuthRepositoryImpl.kt
    - AuthApi.kt
    - AuthDto.kt
    - AuthMapper.kt
\end{verbatim}

Dependencies:

\begin{itemize}
  \item Presentation depends on Domain
  \item Domain defines interfaces
  \item Data implements interfaces from Domain
\end{itemize}

\textbf{Focus Point:} Expose only the required API via a single entry point (e.g., \texttt{AuthFeatureApi}) to decouple modules.

\subsubsection{Best Practices Summary}

\begin{itemize}
  \item Use strict dependency rules with Gradle \texttt{api}/\texttt{implementation}
  \item Avoid tight coupling by using interfaces and DI
  \item Use clear folder and naming conventions aligned with responsibilities
  \item Automate enforcement with lint, static analysis, and test coverage tools
\end{itemize}


\section{Core Coding Practices}

\subsection{Choosing Data Structures and Types}

Choosing the right data structure and type is critical for writing efficient, maintainable, and bug-resistant code. It affects time/space complexity, readability, and scalability.

\paragraph{Data Structures}
A data structure defines how data is stored and accessed. Each structure has trade-offs depending on the use case.

\begin{itemize}
  \item \textbf{Array:} contiguous memory, fast random access (O(1)), fixed size
  \item \textbf{Linked List:} dynamic size, fast insert/remove, slow access (O(n))
  \item \textbf{Stack / Queue:} LIFO / FIFO behavior, often implemented via arrays or linked lists
  \item \textbf{HashMap / HashSet:} fast lookup (avg O(1)), unordered, requires good hash functions
  \item \textbf{Tree (e.g. BST, Heap, Trie):} ordered or hierarchical data, O(log n) for balanced trees
  \item \textbf{Graph:} models relations (edges) between entities (nodes); useful in networks, dependencies, etc.
\end{itemize}

\paragraph{Example — HashSet vs TreeSet in Java}
\begin{itemize}
  \item \textbf{HashSet:} backed by hash table, no order, O(1) operations on average
  \item \textbf{TreeSet:} backed by red-black tree, sorted elements, O(log n) operations
\end{itemize}

\begin{lstlisting}[language=Java]
Set<String> set = new HashSet<>();
set.add("apple"); set.add("banana");

Set<String> sorted = new TreeSet<>(set);
System.out.println(set);    // unordered
System.out.println(sorted); // sorted
\end{lstlisting}

\paragraph{Types and Representations}
Choosing the correct type avoids implicit conversions, overflows, or memory waste.

\begin{itemize}
  \item \textbf{int vs long:} choose based on expected value range
  \item \textbf{float vs double:} trade-off between precision and memory
  \item \textbf{char vs String:} avoid using \texttt{String} for single characters
  \item \textbf{object vs primitive:} prefer primitives when performance matters (no boxing/unboxing)
\end{itemize}

\paragraph{Guidelines}
\begin{itemize}
  \item Use the simplest structure that satisfies the requirements
  \item Consider worst-case complexity, not just average
  \item Account for mutability, ordering, duplication, and frequency of operations
\end{itemize}

\subsection{Memory Management and Resource Handling}

Efficient memory and resource handling prevents leaks, crashes, and performance degradation. Even in managed environments (e.g., Java, Kotlin), understanding how memory works is crucial.

\paragraph{Stack vs Heap}
\begin{itemize}
  \item \textbf{Stack:} stores primitive types and function call frames; fast and automatically managed
  \item \textbf{Heap:} stores objects and dynamically allocated data; managed by the garbage collector
\end{itemize}

\paragraph{Object Lifetime}
Objects on the heap persist until no longer referenced. Poor reference management leads to memory leaks, especially in long-lived components.

\paragraph{Garbage Collection (GC)}
In languages like Java/Kotlin:
\begin{itemize}
  \item GC reclaims unused heap memory
  \item Memory leaks still occur if references are unintentionally retained (e.g., via static fields or listeners)
\end{itemize}

\paragraph{Manual Resource Management}
Resources like file handles, sockets, or database connections must be explicitly released.

\begin{itemize}
  \item Use \texttt{try-with-resources} (Java) or \texttt{use {}} (Kotlin) for automatic cleanup
  \item Always close streams, cursors, and connections even if exceptions occur
\end{itemize}

\begin{lstlisting}[language=Java]
try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
    String line = reader.readLine();
}
\end{lstlisting}

\paragraph{Best Practices}
\begin{itemize}
  \item Avoid holding references longer than needed
  \item Dereference listeners, callbacks, and closures when no longer used
  \item Use profiling tools to detect memory leaks (e.g., VisualVM, Android Profiler)
\end{itemize}

\subsection{Concurrency and Multithreading}

Multithreading enables concurrent execution of tasks to improve responsiveness or performance, especially in I/O-bound or parallelizable workloads.

\subsubsection{Threading Models and Use Cases}

Multiple threads can run in parallel (on multi-core CPUs) or interleaved (on single-core). Common use cases:
\begin{itemize}
  \item Handling I/O without blocking the main thread
  \item Running parallel computations
  \item Background tasks (e.g., logging, network requests)
\end{itemize}

\subsubsection{Common Concurrency Issues}

Concurrency introduces risks due to shared mutable state:
\begin{itemize}
  \item \textbf{Race Condition:} Two threads read/write shared data without synchronization
  \item \textbf{Deadlock:} Two or more threads waiting indefinitely for each other’s resources
  \item \textbf{Livelock:} Threads keep changing state in response to each other but make no progress
\end{itemize}

\subsubsection{Synchronization Techniques}

To avoid unsafe access to shared data:
\begin{itemize}
  \item \textbf{Locks:} \texttt{synchronized}, \texttt{ReentrantLock}, mutexes
  \item \textbf{Atomic Operations:} \texttt{AtomicInteger}, \texttt{compareAndSet()}
  \item \textbf{Thread Pools:} Managed execution via \texttt{ExecutorService}
\end{itemize}

\subsection{Immutability and Side Effects}

Immutability and controlled side effects help prevent bugs, especially in concurrent and functional codebases.

\paragraph{Immutability}
An object is immutable if its state cannot change after construction.

\begin{itemize}
  \item Eliminates shared mutable state issues
  \item Simplifies reasoning, testing, and debugging
  \item Enables safe sharing of data across threads
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Java]
final class User {
    private final String name;
    public User(String name) { this.name = name; }
    public String getName() { return name; }
}
\end{lstlisting}

Use \texttt{val} in Kotlin or \texttt{final} in Java to enforce immutability where possible.

\paragraph{Side Effects}
A side effect is any observable change outside a function’s scope: writing to disk, modifying a global variable, changing input arguments, logging, etc.

Uncontrolled side effects reduce predictability and testability.

\paragraph{Best Practices}
\begin{itemize}
  \item Prefer pure functions: same input → same output, no side effects
  \item Isolate side effects in dedicated layers (e.g., repository, I/O)
  \item Avoid modifying input parameters directly
  \item Use dependency injection to inject side-effecting components
\end{itemize}

\subsection{Error Handling and Fail-Fast Design}

Error handling ensures that failures are detected, communicated, and contained. A fail-fast approach helps catch problems early and avoids hiding bugs.

\paragraph{Fail-Fast Principle}
A system should detect incorrect states as soon as possible and stop execution instead of proceeding with invalid data.

\begin{itemize}
  \item Prevents cascading failures
  \item Simplifies debugging
  \item Encourages clear validation at input boundaries
\end{itemize}

\textbf{Examples:}
\begin{itemize}
  \item Validating arguments in constructors or public methods
  \item Asserting internal invariants early
  \item Failing fast on unsupported states rather than continuing silently
\end{itemize}

\paragraph{Error Handling Strategies}

\begin{itemize}
  \item \textbf{Throw exceptions} on unrecoverable errors
  \item \textbf{Return result wrappers} (e.g., \texttt{Result}, \texttt{Either}) for expected failures
  \item \textbf{Avoid swallowing exceptions} silently
  \item \textbf{Log meaningful context} when errors occur
\end{itemize}

\textbf{Bad:}
\begin{lstlisting}[language=Java]
try {
    // risky code
} catch (Exception e) {
    // do nothing
}
\end{lstlisting}

\textbf{Better:}
\begin{lstlisting}[language=Java]
try {
    doSomething();
} catch (IOException e) {
    logger.error("Failed to doSomething", e);
    throw e;
}
\end{lstlisting}

\paragraph{Best Practices}
\begin{itemize}
  \item Validate inputs early (at boundaries)
  \item Use domain-specific exceptions instead of generic ones
  \item Avoid hiding the root cause
  \item Make failures explicit in function signatures where appropriate
\end{itemize}

\subsection{Efficient Loops and Bulk Operations}

Looping is a fundamental operation; small inefficiencies can scale poorly. Writing efficient loops means reducing unnecessary work, avoiding excessive allocations, and favoring batch operations when possible.

\paragraph{Loop Strategy}

\begin{itemize}
  \item Prefer \textbf{indexed loops} when access patterns are predictable.
  \item Avoid unnecessary recalculations inside loop bodies.
  \item Cache loop-invariant values outside the loop.
  \item Minimize function calls and object creation in hot loops.
\end{itemize}

\textbf{Bad:}
\begin{lstlisting}[language=Java]
for (int i = 0; i < list.size(); i++) {
    doWork(list.size()); // repeated call
}
\end{lstlisting}

\textbf{Better:}
\begin{lstlisting}[language=Java]
int size = list.size();
for (int i = 0; i < size; i++) {
    doWork(size); // cached
}
\end{lstlisting}

\paragraph{Bulk Operations}

When working on large collections or arrays, prefer APIs that apply transformations in bulk:

\begin{itemize}
  \item Use \texttt{map()}, \texttt{filter()}, \texttt{forEach()} when supported
  \item Use streaming or vectorized operations when available (e.g., Java Streams, Kotlin Sequences)
  \item Avoid appending one element at a time if you can process or build in chunks
\end{itemize}

\paragraph{Best Practices}

\begin{itemize}
  \item Use the right data structure for the loop (e.g., avoid \texttt{LinkedList} for indexed access)
  \item Profile hotspots to identify expensive operations
  \item Favor lazy evaluation (streams/sequences) when working with large datasets
\end{itemize}

\subsection{Avoiding Code Smells in Implementation}

Code smells are indicators of suboptimal design choices that reduce code quality and maintainability.

\paragraph{Common Smells and How to Avoid Them}

\begin{itemize}
  \item \textbf{Long Methods:} split into smaller, focused functions
  \item \textbf{Duplicated Code:} extract reusable logic
  \item \textbf{God Object:} divide into smaller, cohesive classes
  \item \textbf{Tight Coupling:} depend on interfaces or abstractions
  \item \textbf{Poor Naming:} use clear, intention-revealing names
  \item \textbf{Primitive Obsession:} replace raw primitives with domain-specific types
\end{itemize}

\paragraph{Bad Example:}
\begin{lstlisting}[language=Java]
public void process(User user) {
    if (user.getAge() > 18) {
        System.out.println("Adult");
        database.save(user);
        email.send(user.getEmail());
    }
}
\end{lstlisting}

\paragraph{Better:}
\begin{lstlisting}[language=Java]
if (user.isAdult()) {
    logAdult(user);
    persistUser(user);
    notifyUser(user);
}
\end{lstlisting}

\paragraph{Best Practices}
\begin{itemize}
  \item Keep methods short and focused
  \item Avoid redundant logic and comments
  \item Refactor continuously, not just during rewrites
  \item Write code that clearly communicates intent
\end{itemize}

\subsection{Debugging and Logging Techniques}

Effective debugging and logging help identify and isolate defects quickly.

\paragraph{Debugging Techniques}

\begin{itemize}
  \item Use breakpoints and step-through debugging to inspect runtime state
  \item Reproduce bugs with minimal test cases
  \item Add assertions to catch unexpected states early
  \item Isolate the failing module or function
\end{itemize}

Avoid relying solely on print statements; use proper debugging tools when available.

\paragraph{Logging Guidelines}

\begin{itemize}
  \item Log structured, meaningful data (e.g., user ID, request ID)
  \item Use appropriate log levels: \texttt{DEBUG}, \texttt{INFO}, \texttt{WARN}, \texttt{ERROR}
  \item Avoid excessive or noisy logging in production
  \item Never log sensitive data (e.g., passwords, tokens)
  \item Include timestamps and context to trace issues across components
\end{itemize}

\textbf{Example (Java):}
\begin{lstlisting}[language=Java]
logger.info("User login attempt", Map.of("userId", user.getId()));
logger.error("Failed to save order", exception);
\end{lstlisting}

\paragraph{Best Practices}

\begin{itemize}
  \item Keep logs consistent across modules
  \item Centralize logging configuration
  \item Use log aggregation tools (e.g., ELK stack, Datadog) in larger systems
\end{itemize}

\subsection{Performance Profiling}

Performance profiling identifies bottlenecks in CPU, memory, or I/O usage.

\paragraph{When to Profile}

\begin{itemize}
  \item When performance issues are observed or suspected
  \item Before optimizing code, to avoid premature optimization
\end{itemize}

\paragraph{What to Measure}

\begin{itemize}
  \item CPU usage: hotspots, tight loops, unnecessary computations
  \item Memory usage: excessive allocation, leaks, object retention
  \item I/O operations: slow disk access, network delays
\end{itemize}

\paragraph{How to Profile}

\begin{itemize}
  \item Use built-in profilers (e.g., VisualVM, JFR, Android Profiler)
  \item Analyze call graphs and allocation traces
  \item Add manual timers or metrics for critical sections
\end{itemize}

\paragraph{Best Practices}

\begin{itemize}
  \item Profile real usage scenarios, not synthetic benchmarks
  \item Focus on high-impact areas first
  \item Avoid optimizing without data
  \item Monitor regressions continuously in CI
\end{itemize}

\subsection{Documentation in Code}

Code should be self-explanatory first, documented second. Good documentation clarifies intent without repeating the obvious.

\paragraph{What to Document}

\begin{itemize}
  \item Public APIs: purpose, parameters, return values, edge cases
  \item Complex logic: why something is done, not how
  \item Assumptions and constraints that aren't obvious from the code
\end{itemize}

\paragraph{What to Avoid}

\begin{itemize}
  \item Redundant comments that restate the code
  \item Outdated or misleading documentation
  \item Excessive inline comments that clutter the code
\end{itemize}

\paragraph{Best Practices}

\begin{itemize}
  \item Use clear naming to reduce the need for comments
  \item Use documentation tools (e.g., KDoc, Javadoc) for public APIs
  \item Keep README files updated per module or package
  \item Use docstrings or block comments for classes and functions
\end{itemize}

\textbf{Example (Kotlin):}
\begin{lstlisting}[language=Kotlin]
/**
 * Returns a user's full name.
 * @param user the user to format
 * @return the full name as "First Last"
 */
fun getFullName(user: User): String
\end{lstlisting}

\section{Core Android Components and System Behavior}

\subsection{Application Architecture Overview}

\subsubsection{Main Components of an Android App}

Android apps are built using four main component types:

\begin{itemize}
  \item \textbf{Activities:} Represent UI screens and handle direct user interaction. Each screen typically maps to one activity. Activities handle lifecycle events and navigation.
  
  \item \textbf{Fragments:} Reusable portions of UI logic embedded in activities. They allow more modular and flexible UI designs, especially for tablets and multi-pane layouts.
  
  \item \textbf{Services:} Run background operations with no direct UI (e.g., uploading a file, playing music). Services may be long-lived and must handle lifecycle carefully to avoid leaks or unexpected termination.
  
  \item \textbf{Broadcast Receivers:} Respond to broadcasted events, either system-wide (e.g., low battery) or custom app events. Lightweight and short-lived; they run in the app’s main thread.
  
  \item \textbf{Content Providers:} Allow structured access to app data and share it across apps (e.g., contacts, media). Use URIs and enforce permission checks.
\end{itemize}

These components interact using \textbf{Intents}, which can carry data and specify actions. The system uses intents to resolve which component should handle the action.

\textbf{Focus point:} Know when to use each component, how they interact, and how their lifecycles differ. When designing a feature, choose the components that best fit its responsibilities and scope.

\subsubsection{The Application Class and Its Role}

The \texttt{Application} class is the first component created when the app process starts. It provides a global context and lifecycle for app-level initialization.

\textbf{Typical responsibilities:}
\begin{itemize}
  \item Initializing libraries (e.g., Hilt, Timber, Firebase)
  \item Creating singletons or services that need app-wide scope
  \item Managing dependency injection graphs
  \item Storing global state (with caution)
\end{itemize}

\textbf{Implementation:}
\begin{lstlisting}[language=Java]
public class MyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        // e.g., setup logger or DI
    }
}
\end{lstlisting}

Declare it in the manifest:
\begin{lstlisting}[language=xml]
<application
    android:name=".MyApp"
    ... >
</application>
\end{lstlisting}

\textbf{Focus point:} Understand why centralizing setup in the \texttt{Application} class is useful, and avoid holding references to Activities or Views to prevent memory leaks.

\subsubsection{The Android Manifest and Its Purpose}

The \texttt{AndroidManifest.xml} is a required file that tells the Android system how the app is structured and what it needs to run.

\textbf{Key responsibilities:}
\begin{itemize}
\item Declare app \textbf{components}: activities, services, broadcast receivers, content providers.
\item Specify required \textbf{permissions} (e.g., camera, location).
\item Set \textbf{app-level configuration}: app name, icons, themes, min/max SDK versions.
\item Define \textbf{intent filters} for implicit intent handling (e.g., opening links, file types).
\item Configure \textbf{deep links} via intent filters to allow external URLs or URIs to open specific screens in the app.
\end{itemize}

It is also where you declare:
\begin{itemize}
  \item Your \texttt{Application} class
  \item The launch activity (\texttt{intent-filter} with \texttt{MAIN} and \texttt{LAUNCHER})
  \item Third-party integrations (e.g., Firebase services)
\end{itemize}

\textbf{Focus point:} Know how the manifest controls app startup, permissions, and inter-app communication. Understand the difference between declaring and requesting permissions, and how intent filters enable deep linking and external triggers.

\subsection{Activity and Fragment Lifecycle}

\subsubsection{Activity Lifecycle}

Defines the states of an activity from creation to destruction.

\begin{itemize}
  \item \textbf{onCreate()}: Initialize UI, ViewModels, bindings.
  \item \textbf{onStart()}: Activity becomes visible.
  \item \textbf{onResume()}: Activity is interactive.
  \item \textbf{onPause()}: Activity partially hidden. Save transient state, pause animations/sensors.
  \item \textbf{onStop()}: Fully hidden. Release heavy resources.
  \item \textbf{onRestart()}: Called before \texttt{onStart()} after being stopped.
  \item \textbf{onDestroy()}: Final cleanup before the activity is removed.
\end{itemize}

\textbf{Focus point:} Use \texttt{onStart/onStop} to register and unregister listeners based on visibility.

\textbf{Focus point:} Keep UI logic out of \texttt{onResume()}; reserve it for resuming suspended operations.

\textbf{Focus point:} Release heavy resources (e.g., Camera, Location) no later than in \texttt{onStop()} to prevent leaks or crashes.


\subsubsection{Fragment Lifecycle and View Lifecycle}

Fragments have two lifecycles:
\begin{itemize}
  \item \textbf{Fragment lifecycle:} creation and destruction of the fragment instance.
  \item \textbf{View lifecycle:} creation and destruction of the fragment’s view.
\end{itemize}

\paragraph{Fragment Lifecycle}
\begin{itemize}
  \item \textbf{onAttach()}: Fragment attached to context.
  \item \textbf{onCreate()}: Initialize ViewModel or logic.
  \item \textbf{onCreateView()}: Inflate UI. View lifecycle starts here.
  \item \textbf{onViewCreated()}: View is ready. Bind views, observe LiveData.
  \item \textbf{onStart()} / \textbf{onResume()}: UI becomes active.
  \item \textbf{onPause()} / \textbf{onStop()}: UI losing focus.
  \item \textbf{onDestroyView()}: Cleanup view bindings.
  \item \textbf{onDestroy()}: Cleanup fragment state.
  \item \textbf{onDetach()}: Fragment removed from activity.
\end{itemize}

\paragraph{View Lifecycle}

The view exists from \texttt{onCreateView()} to \texttt{onDestroyView()}. Important for:

\begin{itemize}
  \item ViewBinding / DataBinding
  \item LiveData observation via \texttt{viewLifecycleOwner}
  \item Coroutines using \texttt{viewLifecycleOwner.lifecycleScope}
\end{itemize}

\textbf{Focus point:} Never reference views outside the view lifecycle.

\textbf{Focus point:} Always clear bindings in \texttt{onDestroyView()}.

\textbf{Focus point:} Observe LiveData inside \texttt{onViewCreated()} using \texttt{viewLifecycleOwner}.

\paragraph{Fragment vs View Lifecycle}

\begin{itemize}
  \item Fragment may exist without its view (e.g., during rotation).
  \item View lifecycle must be managed separately to avoid memory leaks.
\end{itemize}

\subsubsection{What Happens When Android App is Launched?}

\begin{enumerate}
  \item \texttt{Application.onCreate()} is triggered.
  \item System instantiates the launch activity.
  \item Activity lifecycle: \texttt{onCreate → onStart → onResume}
\end{enumerate}

\textbf{Focus point:} Understand the difference between cold, warm, and hot starts — especially how they impact perceived performance.

\textbf{Focus point:} \texttt{Application.onCreate()} is the first method called when the app process starts; it's ideal for global initialization.

\subsubsection{UI State Preservation on Configuration Changes}

On rotation or config change, components are destroyed and recreated.

\begin{itemize}
  \item \textbf{onSaveInstanceState()}: Saves transient state (text input, scroll position).
  \item \textbf{ViewModel}: Retains non-UI logic across config changes.
  \item \textbf{SavedStateHandle}: Stores key-value pairs in ViewModel, survives process death.
\end{itemize}

\textbf{Focus point:} Use \texttt{onSaveInstanceState()} to persist transient UI state, and \texttt{ViewModel} to retain business logic across configuration changes.

\textbf{Focus point:} \texttt{SavedStateHandle} is designed for restoring ViewModel state after process death or recreation.

\subsubsection{Context and Its Relation to Activity}

\texttt{Context} provides access to app resources, files, and system services.

\textbf{Common uses:}
\begin{itemize}
  \item \texttt{getResources()}, \texttt{getSystemService()}
  \item \texttt{startActivity()}, \texttt{openFileInput()}
\end{itemize}

\textbf{Types:}
\begin{itemize}
  \item \textbf{Activity context}: tied to UI, should not be retained.
  \item \textbf{Application context}: long-lived, safe for singletons/repositories.
\end{itemize}

\textbf{Focus point:} Use \texttt{applicationContext} when passing context to long-lived components like repositories or singletons.

\textbf{Focus point:} Avoid holding activity context in singletons — it can lead to memory leaks due to lingering references.

\paragraph{Example}
\begin{lstlisting}[language=Kotlin]
class Repository(context: Context) {
    private val appContext = context.applicationContext
}
\end{lstlisting}


\subsection{Communication Between Components}

Android provides different mechanisms for communication between components (activities, services, receivers, etc.), mainly using \texttt{Intents}, \texttt{Broadcast Receivers}, and \texttt{Services}. Choosing the right mechanism depends on the use case: synchronous vs asynchronous, one-to-one vs one-to-many, local vs system-wide.

\subsubsection{Intents: Explicit vs Implicit}

An \textbf{Intent} is a messaging object used to request an action from another component.

\textbf{Explicit intents} specify the exact class to be started. They're used for in-app navigation:
\begin{itemize}
  \item Starting an activity within the app
  \item Launching a service
\end{itemize}

\textbf{Implicit intents} describe the action to be performed, without specifying a target class. The system resolves them to matching components, even across apps.

\begin{itemize}
  \item Common for inter-app communication (e.g., share text, open URL)
  \item Resolved using intent filters declared in the manifest
\end{itemize}

\textbf{Focus point:} Understand how intent resolution works. If multiple apps match, the system shows a chooser; if none match, handle it safely using \texttt{resolveActivity()} before launching.

\textbf{Example – Explicit:}
\begin{lstlisting}[language=Java]
Intent intent = new Intent(this, LoginActivity.class);
startActivity(intent);
\end{lstlisting}

\textbf{Example – Implicit:}
\begin{lstlisting}[language=Java]
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.setData(Uri.parse("https://example.com"));
if (intent.resolveActivity(getPackageManager()) != null) {
    startActivity(intent);
}
\end{lstlisting}

\subsubsection{Broadcast Receivers}

\textbf{Broadcast Receivers} allow apps to listen for system or custom events. They are one-to-many: one event can reach multiple receivers.

\textbf{Static registration (Manifest)}:
\begin{itemize}
  \item Triggered even if the app is not running
  \item Limited in newer Android versions (e.g., background restrictions)
\end{itemize}

\textbf{Dynamic registration (Code)}:
\begin{itemize}
  \item Registered in code (usually in \texttt{onStart()}, unregistered in \texttt{onStop()})
  \item Only active while the app is in memory
\end{itemize}

\textbf{Common use cases:}
\begin{itemize}
  \item System events (e.g., airplane mode change, battery low)
  \item Internal app events using \texttt{LocalBroadcastManager} (deprecated in favor of alternatives like \texttt{LiveData} or event buses)
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Java]
BroadcastReceiver receiver = new BroadcastReceiver() {
    public void onReceive(Context context, Intent intent) {
        // Handle event
    }
};
registerReceiver(receiver, new IntentFilter("com.example.MY_EVENT"));
\end{lstlisting}

\textbf{Focus point:} Choose between \texttt{BroadcastReceiver}, callbacks, or \texttt{LiveData} based on the use case. Be aware that static receivers are limited starting from Android 8+ unless explicitly registered in the manifest with specific intent filters.

\subsubsection{Services: Bound vs Unbound}

A \textbf{Service} is a component for background work without a UI.

\textbf{Unbound services:}
\begin{itemize}
  \item Started with \texttt{startService()} or \texttt{startForegroundService()}
  \item Run independently; must call \texttt{stopSelf()} or be stopped explicitly
  \item Suitable for one-off tasks (e.g., sync, file upload)
\end{itemize}

\textbf{Bound services:}
\begin{itemize}
  \item Clients bind with \texttt{bindService()}
  \item Provides a two-way communication channel (via interface or Binder)
  \item Useful for long-running tasks requiring interaction (e.g., media playback)
\end{itemize}

\textbf{Important distinctions:}
\begin{itemize}
  \item Bound services die when no client is bound
  \item Unbound services live independently until stopped
  \item Foreground services show a persistent notification and are harder to kill
\end{itemize}

\textbf{Focus point:} Understand when to use bound vs unbound services. Know how to implement a bound service with \texttt{Binder} or \texttt{Messenger}, and be aware of background service limitations introduced in Android 8+.

\textbf{Example – Unbound:}
\begin{lstlisting}[language=Java]
Intent intent = new Intent(this, UploadService.class);
startService(intent);
\end{lstlisting}

\textbf{Example – Bound:}
\begin{lstlisting}[language=Java]
// inside Service
public class MyService extends Service {
    private final IBinder binder = new LocalBinder();
    public class LocalBinder extends Binder {
        MyService getService() {
            return MyService.this;
        }
    }
    public IBinder onBind(Intent intent) {
        return binder;
    }
}
\end{lstlisting}

\subsection{Background Work and Scheduling}

\subsubsection{WorkManager vs JobScheduler}

\textbf{WorkManager} and \textbf{JobScheduler} are APIs for scheduling deferrable background tasks. They differ in capabilities, compatibility, and use cases.

\paragraph{WorkManager}
Recommended for all background work that must be guaranteed to run, even if the app is killed or device restarts.

\textbf{Features:}
\begin{itemize}
  \item Supports constraints (network, charging, idle state).
  \item Automatically chooses the best underlying scheduler (JobScheduler, AlarmManager, etc.).
  \item Supports retries, chaining, and input/output passing.
  \item Compatible with Android 6+ (via fallback mechanisms).
\end{itemize}

\begin{lstlisting}[language=Kotlin]
val work = OneTimeWorkRequestBuilder<UploadWorker>().build()
WorkManager.getInstance(context).enqueue(work)
\end{lstlisting}

\textbf{Use when:}
\begin{itemize}
  \item You need reliable execution.
  \item Work must survive app kill or device reboot.
  \item You want modern APIs and backward compatibility.
\end{itemize}

\textbf{Focus point:} \texttt{WorkManager} is lifecycle-aware and survives app restarts and device reboots.

\textbf{Focus point:} Use \texttt{WorkManager} for deferrable, guaranteed background tasks like syncing, uploads, or analytics dispatch.

\paragraph{JobScheduler}

Available from API 21+. Schedules jobs with system-managed execution based on constraints.

\textbf{Limitations:}
\begin{itemize}
  \item No backward compatibility.
  \item More boilerplate code.
  \item Less flexible than WorkManager.
\end{itemize}

\textbf{Focus point:} \texttt{JobScheduler} is a lower-level API available from Android 5. Use it only when \texttt{WorkManager} is not applicable or finer control over job conditions is needed.

\textbf{Comparison:}
\begin{itemize}
  \item \textbf{WorkManager} wraps and improves upon \textbf{JobScheduler}.
  \item WorkManager is the default choice unless there's a very specific reason to use JobScheduler.
\end{itemize}

\subsubsection{Content Providers}

Content Providers manage access to structured data. They allow data to be shared:
\begin{itemize}
  \item Between different components of the same app
  \item Across different apps using URIs
\end{itemize}

\textbf{Key APIs:}
\begin{itemize}
  \item \texttt{ContentResolver}: used to query, insert, update, and delete data
  \item \texttt{UriMatcher}: used to match incoming URIs to known operations
\end{itemize}

\textbf{Typical usage:}
\begin{itemize}
  \item Expose app data (e.g., contacts, files) to other apps.
  \item React to data changes via \texttt{ContentObserver}.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
val cursor = contentResolver.query(
    ContactsContract.Contacts.CONTENT_URI,
    null, null, null, null
)
\end{lstlisting}

\textbf{Focus point:} Use \texttt{ContentProvider} only when sharing data across apps is required.

\textbf{Focus point:} \texttt{ContentProvider} is also used internally by frameworks like Room via \texttt{ContentObserver} to observe data changes.

\subsection{Data Handling and Persistence}

\subsubsection{How Data Persistence Works in Android}

Data persistence allows you to store and retrieve data across sessions. Android provides multiple mechanisms, each suitable for specific use cases.

\textbf{Storage options:}
\begin{itemize}
  \item \textbf{SharedPreferences}: key-value pairs for small, primitive data (e.g., user settings).
  \item \textbf{Internal Storage}: private file storage within the app sandbox.
  \item \textbf{External Storage}: files accessible outside the app (requires permissions).
  \item \textbf{SQLite}: lightweight relational database for structured data.
  \item \textbf{Room}: abstraction over SQLite for safer and easier access.
\end{itemize}

\textbf{Focus point:} Use \texttt{SharedPreferences} only for lightweight key-value pairs like settings or flags — not for complex structured data.

\textbf{Focus point:} Internal storage is private to the app; external storage access requires runtime permissions starting from Android 6+.

\textbf{Focus point:} SQLite offers full control over relational data but introduces boilerplate and is error-prone without abstraction layers like Room.

\subsubsection{What Is Room and How to Use It}

\textbf{Room} is a Jetpack library that provides an abstraction layer over SQLite, using annotations and compile-time checks.

\textbf{Main components:}
\begin{itemize}
  \item \texttt{@Entity}: defines a table.
  \item \texttt{@Dao}: contains methods to access the database (e.g., \texttt{@Query}, \texttt{@Insert}).
  \item \texttt{@Database}: main class that provides a database instance.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
@Entity
data class User(
    @PrimaryKey val id: Int,
    val name: String
)

@Dao
interface UserDao {
    @Query("SELECT * FROM User")
    fun getAll(): List<User>
}

@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
\end{lstlisting}

\textbf{How to create an instance:}
\begin{lstlisting}[language=Kotlin]
val db = Room.databaseBuilder(
    context,
    AppDatabase::class.java,
    "my-db"
).build()
\end{lstlisting}

\textbf{Focus point:} Room validates SQL at compile time, helping catch errors early.

\textbf{Focus point:} Use DAOs for all Room access — avoid raw SQL execution outside of them.

\textbf{Focus point:} Expose reactive streams from DAO methods using \texttt{Flow} or \texttt{LiveData} for automatic UI updates.

\textbf{Focus point:} Handle Room migrations explicitly to preserve user data across schema changes.


\subsection{Networking and External Communication}

\subsubsection{What Is Retrofit?}

\textbf{Retrofit} is a type-safe HTTP client for Android and Java, developed by Square. It simplifies communication with REST APIs by converting HTTP APIs into Kotlin/Java interfaces.

\textbf{Core concepts:}
\begin{itemize}
  \item Uses annotations to define endpoints (\texttt{@GET}, \texttt{@POST}, etc.)
  \item Supports dynamic URLs, query parameters, headers, and form data.
  \item Integrates with converters (e.g., Gson, Moshi) for JSON serialization.
  \item Supports suspend functions and RxJava/Flow.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
interface ApiService {
    @GET("users/{id}")
    suspend fun getUser(@Path("id") id: Int): User
}

val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .addConverterFactory(GsonConverterFactory.create())
    .build()

val service = retrofit.create(ApiService::class.java)
\end{lstlisting}

\textbf{Focus point:} Use Retrofit for REST APIs — it simplifies networking with built-in converters, async handling, and error parsing.

\textbf{Focus point:} Pair Retrofit with OkHttp to add interceptors, logging, timeouts, and caching behavior.

\textbf{Focus point:} Use \texttt{suspend} functions in Retrofit interfaces for seamless coroutine integration and cleaner async code.

\textbf{Focus point:} Handle HTTP error responses (4xx, 5xx) explicitly to prevent silent failures and improve UX.

\subsubsection{Other Networking Tools}

\begin{itemize}
  \item \textbf{OkHttp:} Underlying HTTP client used by Retrofit. Supports interceptors, caching, timeouts, and WebSockets.
  \item \textbf{Volley:} Google’s networking library, suitable for simple requests or image loading. Less popular today.
  \item \textbf{Ktor:} Coroutine-based framework by JetBrains. More flexible but less Android-specific.
  \item \textbf{Moshi / Gson:} JSON parsing libraries, used with Retrofit or standalone.
\end{itemize}

\textbf{Focus point:} Master OkHttp interceptors — they're key for logging, modifying headers, and request inspection.

\textbf{Focus point:} Don’t mix Volley and Retrofit in the same codebase; use Retrofit with OkHttp for a consistent networking stack.

\textbf{Focus point:} Prefer Moshi over Gson for better performance and Kotlin support in modern Android apps.

\subsection{UI and Rendering}

\subsubsection{RecyclerView: Concept and Usage}

\textbf{RecyclerView} is a flexible and efficient component for displaying large datasets in a scrollable list or grid.

\textbf{Key components:}
\begin{itemize}
  \item \texttt{Adapter}: binds data to views.
  \item \texttt{ViewHolder}: holds references to views for reuse.
  \item \texttt{LayoutManager}: controls layout (e.g., linear, grid).
  \item \texttt{DiffUtil}: optimizes updates by comparing item differences.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
class UserAdapter : ListAdapter<User, UserViewHolder>(DiffCallback) {
    override fun onCreateViewHolder(...) = ...
    override fun onBindViewHolder(...) = ...
}
\end{lstlisting}

\textbf{Focus point:} Use \texttt{ListAdapter} with \texttt{DiffUtil} for efficient and automatic list updates.

\textbf{Focus point:} Avoid view lookup inside \texttt{onBindViewHolder()}; leverage the ViewHolder pattern for better performance.

\textbf{Focus point:} Use \texttt{setHasStableIds(true)} if items have unique IDs — it improves animations and state restoration.

\subsubsection{Jetpack Compose}

\textbf{Jetpack Compose} is a modern UI toolkit for building native UI with declarative Kotlin code.

\textbf{Core ideas:}
\begin{itemize}
  \item UI is defined as composable functions.
  \item State drives UI — updates trigger recomposition.
  \item No need for XML or manual view hierarchy.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
@Composable
fun Greeting(name: String) {
    Text("Hello, $name!")
}
\end{lstlisting}

\textbf{Focus point:} Annotate UI functions with \texttt{@Composable} and manage local state using \texttt{remember} and \texttt{mutableStateOf}.

\textbf{Focus point:} Adopt Jetpack Compose for new development — it's the recommended modern toolkit for Android UI.

\textbf{Focus point:} Understand Compose integration with \texttt{ViewModel}, \texttt{Navigation}, and app-level state management.

\subsubsection{Custom Views}

Custom views are needed when default components don’t meet specific UI or performance requirements.

\textbf{Approaches:}
\begin{itemize}
  \item \textbf{Subclassing View}: override \texttt{onDraw()}, \texttt{onMeasure()}.
  \item \textbf{Combining views}: inflate custom layouts via XML or code.
\end{itemize}

\textbf{Use cases:}
\begin{itemize}
  \item Custom UI elements (e.g., graphs, animated components).
  \item Complex touch handling.
\end{itemize}

\textbf{Focus point:} Use \texttt{Canvas} and \texttt{Paint} APIs to draw custom graphics in views.

\textbf{Focus point:} Avoid deep or nested view hierarchies — they negatively impact rendering performance.

\textbf{Focus point:} Override \texttt{onMeasure()} and \texttt{onLayout()} correctly to ensure proper sizing and positioning in custom views.

\subsubsection{Themes and Styles}

Themes and styles separate UI appearance from logic and enable consistent design across the app.

\textbf{Styles}:
\begin{itemize}
  \item Define text appearance, padding, backgrounds, etc.
  \item Reusable via \texttt{style="@style/MyButtonStyle"}
\end{itemize}

\textbf{Themes}:
\begin{itemize}
  \item Define global look: colors, fonts, shapes.
  \item Applied in \texttt{AndroidManifest.xml}
\end{itemize}

\textbf{Material Components:}
Use the Material theme and tokens (e.g., \texttt{colorPrimary}, \texttt{textAppearance}) for consistency.

\textbf{Focus point:} Use themes to define global UI defaults, and styles for customizing individual components.

\textbf{Focus point:} Avoid hardcoded values — define colors, text sizes, and dimensions in resource files for consistency and scalability.

\textbf{Focus point:} Support light and dark modes by customizing \texttt{Theme.Material3.DayNight} and using theme-aware attributes.

\subsection{Security and Permissions}

\subsubsection{Android Permission System}

Android uses a permission system to restrict access to sensitive data and system features. Permissions must be declared in the \texttt{AndroidManifest.xml} and may require user approval at runtime.

\textbf{Types of permissions:}
\begin{itemize}
  \item \textbf{Normal}: automatically granted (e.g., Internet).
  \item \textbf{Dangerous}: require runtime approval (e.g., location, camera, storage).
  \item \textbf{Special}: system-level (e.g., SYSTEM\_ALERT\_WINDOW).
\end{itemize}

\textbf{How it works:}
\begin{itemize}
  \item Declared in manifest via \texttt{<uses-permission>}.
  \item For dangerous permissions, request via API at runtime (from API 23+).
  \item The user can revoke permissions at any time via system settings.
\end{itemize}

\textbf{Focus point:} Only dangerous permissions (e.g., camera, location) require runtime permission requests.

\textbf{Focus point:} Always check permission status with \texttt{ContextCompat.checkSelfPermission()} before accessing protected resources.

\textbf{Focus point:} Prefer intent-based actions (e.g., \texttt{ACTION\_CALL}) when possible to delegate responsibility and reduce permission scope.

\subsubsection{Runtime Permissions Best Practices}

\textbf{Best practices for requesting and handling dangerous permissions:}
\begin{itemize}
  \item \textbf{Request only when needed}: avoid asking on app launch.
  \item \textbf{Explain why}: show rationale using \texttt{shouldShowRequestPermissionRationale()}.
  \item \textbf{Handle denial}: gracefully degrade features or guide user to settings.
  \item \textbf{Group requests}: avoid multiple back-to-back prompts.
  \item \textbf{Use libraries}: like Accompanist or ActivityResult API for simpler handling.
\end{itemize}

\textbf{Focus point:} Show clear in-app rationale before requesting a permission to improve user trust and acceptance.

\textbf{Focus point:} If the user selects “Don’t ask again,” guide them to app settings using \texttt{ACTION\_APPLICATION\_DETAILS\_SETTINGS}.

\textbf{Focus point:} Use \texttt{ActivityResultContracts.RequestPermission()} for a clean and modern way to request and handle permission results.

\subsection{Navigation and Modern Practices}

\subsubsection{Navigation Component Overview}

The \textbf{Navigation Component} is a Jetpack library that simplifies navigation between fragments, activities, and dialogs using a single navigation graph.

\textbf{Key features:}
\begin{itemize}
  \item Centralized navigation graph (\texttt{nav\_graph.xml}).
  \item SafeArgs: generates type-safe argument passing between destinations.
  \item Back stack management handled automatically.
  \item Supports nested navigation and deep links.
\end{itemize}

\textbf{Focus point:} Use SafeArgs to generate type-safe navigation arguments and prevent runtime key mismatches.

\textbf{Focus point:} Prefer Navigation Component over manual fragment transactions for improved consistency and back stack handling.

\textbf{Focus point:} Adopt a single-activity architecture using fragments as destinations to centralize navigation and simplify deep linking.

\subsubsection{ViewBinding vs DataBinding}

Both allow binding views to code, but serve different purposes:

\textbf{ViewBinding:}
\begin{itemize}
  \item Generates binding classes for each layout.
  \item Type-safe and null-safe access to views.
  \item No support for binding expressions in XML.
\end{itemize}

\textbf{DataBinding:}
\begin{itemize}
  \item Allows binding expressions in XML (\texttt{@{...}}).
  \item Supports observable data and two-way binding.
  \item Adds compile-time and runtime overhead.
\end{itemize}

\textbf{Focus point:} Use ViewBinding for type-safe, boilerplate-free view access with minimal setup.

\textbf{Focus point:} Choose DataBinding only when XML-based logic or two-way data binding is required.

\textbf{Focus point:} Avoid combining DataBinding and Jetpack Compose — stick to a single UI paradigm for consistency and maintainability.

\subsubsection{Integrating Hilt in Android}

\textbf{Hilt} is a dependency injection library built on top of Dagger, designed for Android.

\textbf{Integration steps:}
\begin{itemize}
  \item Add Gradle dependencies for Hilt.
  \item Annotate your \texttt{Application} class with \texttt{@HiltAndroidApp}.
  \item Use \texttt{@AndroidEntryPoint} on activities/fragments.
  \item Use \texttt{@HiltViewModel} on viewModels.
  \item Use \texttt{@Inject} to request dependencies in constructors.
\end{itemize}

\textbf{Scopes:}
\begin{itemize}
  \item \texttt{@Singleton} for app-wide instances.
  \item \texttt{@ActivityRetainedScoped}, \texttt{@ViewModelScoped} for component-level lifecycles.
\end{itemize}

\textbf{Focus point:} Use Hilt for dependency injection with lifecycle awareness and reduced boilerplate compared to Dagger.

\textbf{Focus point:} Enable injection by annotating components like \texttt{Activity}, \texttt{Fragment}, and \texttt{ViewModel} with \texttt{@AndroidEntryPoint} and \texttt{@HiltViewModel}.

\textbf{Focus point:} Keep Hilt modules modular and focused — avoid large modules with unrelated bindings.


\section{Kotlin}

\subsection{Kotlin vs Java}

\subsubsection{Advantages of Kotlin over Java}

Kotlin, developed by JetBrains, is a modern language that offers several advantages over Java, especially for Android development. Key benefits include:

\subsubsection{Kotlin vs Java}

Kotlin improves upon Java by offering modern language features, reducing boilerplate, and improving safety.

\begin{itemize}
  \item \textbf{Null Safety}: Nullable types are part of the type system, reducing \texttt{NullPointerException}s at compile time.
  \item \textbf{Data Classes}: Use \texttt{data class} to automatically generate \texttt{equals()}, \texttt{hashCode()}, \texttt{toString()}, and \texttt{copy()}.
  \item \textbf{Extension Functions}: Add new methods to existing classes without inheritance.
  \item \textbf{Type Inference}: Explicit types are often optional, making code cleaner.
  \item \textbf{Smart Casts}: The compiler automatically casts after \texttt{is} and null checks.
  \item \textbf{Simplified Getters/Setters}: Properties use implicit getters/setters; supports delegation.
  \item \textbf{Coroutines}: Provide structured concurrency and simplify async code without callbacks.
  \item \textbf{Multiplatform Support}: Share code across Android, iOS, and other platforms with Kotlin Multiplatform.
  \item \textbf{Conciseness}: Kotlin reduces boilerplate code, improving readability and maintainability.
  \item \textbf{Full Java Interoperability}: Kotlin works seamlessly with Java libraries and codebases.
\end{itemize}

\textbf{Focus Point:} Kotlin is not just syntactic sugar — it enforces safer practices (null safety), introduces functional patterns (extension functions, lambdas), and simplifies concurrency (coroutines), all while being fully interoperable with Java.

\subsubsection{Difference Between \texttt{open} and \texttt{public}}

\begin{itemize}
\item \texttt{public}: Default visibility modifier. The class or member is accessible from anywhere.
\item \texttt{open}: Allows a class or member to be \texttt{overridden} or \texttt{inherited}. By default, classes and methods in Kotlin are \texttt{final}.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
open class Animal {
open fun sound() { println("...") }
}

class Dog : Animal() {
override fun sound() { println("Bark") }
}
\end{lstlisting}

\textbf{Deep dive:} In Kotlin, unlike Java, inheritance must be explicitly enabled using \texttt{open}.

\subsubsection{\texttt{lateinit} vs Initialized Properties}

\texttt{lateinit} allows you to declare a non-null variable without initializing it immediately.

\begin{itemize}
\item Must be a \texttt{var}, not \texttt{val}.
\item Cannot be used with primitive types (e.g., \texttt{Int}, \texttt{Boolean}).
\item You must guarantee that the property is initialized before accessing it.
\end{itemize}

\textbf{When to use:} For dependency injection, view binding, or test setup.

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
lateinit var viewModel: MyViewModel

fun init() {
viewModel = ...
}
\end{lstlisting}

\textbf{Deep dive:} Accessing a \texttt{lateinit} property before initialization throws \texttt{UninitializedPropertyAccessException}.

\subsubsection{lateinit vs lazy}

\texttt{lateinit} and \texttt{lazy} are both used for deferred initialization, but they differ significantly in behavior and use case:

\begin{itemize}
  \item \textbf{Mutability:}
    \begin{itemize}
      \item \texttt{lateinit} can only be used with \texttt{var} (mutable).
      \item \texttt{lazy} only works with \texttt{val} (immutable).
    \end{itemize}

  \item \textbf{Initialization timing:}
    \begin{itemize}
      \item \texttt{lateinit} must be assigned manually before use.
      \item \texttt{lazy} runs the initialization lambda only once on first access.
    \end{itemize}

  \item \textbf{Thread-safety:}
    \begin{itemize}
      \item \texttt{lateinit} is not thread-safe.
      \item \texttt{lazy} is thread-safe by default (\texttt{LazyThreadSafetyMode.SYNCHRONIZED}).
    \end{itemize}

  \item \textbf{Reinitialization:}
    \begin{itemize}
      \item \texttt{lateinit} can be reassigned.
      \item \texttt{lazy} cannot be reset or reassigned.
    \end{itemize}

  \item \textbf{Type restrictions:}
    \begin{itemize}
      \item \texttt{lateinit} cannot be used with primitive types.
      \item \texttt{lazy} supports primitives.
    \end{itemize}

  \item \textbf{Introspection:}
    \begin{itemize}
      \item \texttt{lateinit} supports checking if initialized via \texttt{::property.isInitialized}.
      \item \texttt{lazy} does not support this.
    \end{itemize}

  \item \textbf{Use Cases:}
    \begin{itemize}
      \item Use \texttt{lateinit} for dependency injection, view bindings, or properties set externally.
      \item Use \texttt{lazy} for expensive computations that should only run when needed and should not change.
    \end{itemize}
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
// lateinit
lateinit var viewModel: MyViewModel

// lazy
val config by lazy {
    loadConfigFromDisk()
}
\end{lstlisting}

\textbf{Focus Point:} Use \texttt{lateinit} for mutable, externally-initialized objects. Use \texttt{lazy} for immutable, internally-managed values that should load only on demand.


\subsection{Kotlin Fundamentals}

\subsubsection{Lambda Expressions}

A \textbf{lambda expression} is an anonymous function used to simplify function passing and inline logic.

\textbf{Syntax:}
\begin{lstlisting}[language=Kotlin]
val add = { x: Int, y: Int -> x + y }
val doubled = list.map { it * 2 }
\end{lstlisting}

\textbf{Key features:}
\begin{itemize}
  \item Passed as arguments to higher-order functions.
  \item Can capture external variables.
  \item Use \texttt{it} as implicit name for single-parameter lambdas.
\end{itemize}

\textbf{Focus Point:} Lambdas power many Kotlin idioms like collection transformations, callbacks, and DSLs.

\subsubsection{Special Keywords: \texttt{this}, \texttt{it}, \texttt{object}, etc.}

\begin{itemize}
  \item \textbf{\texttt{this}}: Refers to the current object. Inside lambdas with a receiver (like \texttt{apply}), it refers to the receiver.
  \item \textbf{\texttt{it}}: Implicit name for single-parameter lambda argument.
  \item \textbf{\texttt{object}}: Used to declare anonymous classes or singletons.
  \item \textbf{\texttt{companion object}}: Used for static-like members inside classes.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
val list = listOf(1, 2, 3)
list.filter { it > 1 }

class Example {
    companion object {
        val TAG = "Example"
    }
}
\end{lstlisting}

\subsubsection{Companion Objects}

A \textbf{companion object} allows static-like declarations in classes. It is initialized when the class is first accessed and can hold constants, factories, or utility functions.

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
class Utils {
    companion object {
        const val VERSION = "1.0"
        fun log(msg: String) { println(msg) }
    }
}
\end{lstlisting}

\textbf{Focus Point:} Companion objects replace static members and can be extended, implement interfaces, or be annotated (e.g., with \texttt{@JvmStatic}).

\subsubsection{Kotlin Annotations for Java Interop}

Annotations that help Kotlin interoperate cleanly with Java:

\begin{itemize}
  \item \textbf{@JvmStatic}: Makes methods in \texttt{companion object} callable from Java as static methods.
  \item \textbf{@JvmOverloads}: Generates overloads for functions with default arguments.
  \item \textbf{@JvmField}: Exposes a Kotlin property as a public Java field.
\end{itemize}

\textbf{Focus Point:} Use these annotations when writing Kotlin that will be consumed from Java code or when using Java-based frameworks (e.g., Android SDK).


\subsection{Type System}

\subsubsection{enum class}

An \texttt{enum class} defines a fixed set of constants. Each value is a singleton instance. Enums are useful when you know all possible values at compile time.

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
enum class Direction {
    NORTH, SOUTH, EAST, WEST
}
\end{lstlisting}

\textbf{Features:}
\begin{itemize}
  \item Each enum constant can have properties and methods.
  \item All constants are instances of the same type.
  \item Enum values are accessible via \texttt{.values()} or \texttt{.valueOf()}.
\end{itemize}

\textbf{Use cases:} Directions, Status codes, UI modes.

\subsubsection{sealed class}

A \texttt{sealed class} restricts class hierarchy to a fixed set of subclasses. All subclasses must be defined in the same file.

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
sealed class NetworkResult
data class Success(val data: String) : NetworkResult()
data class Error(val code: Int) : NetworkResult()
object Loading : NetworkResult()
\end{lstlisting}

\textbf{Features:}
\begin{itemize}
  \item Enables exhaustive \texttt{when} expressions without an \texttt{else}.
  \item Can hold state or structure.
  \item Allows inheritance and polymorphism.
\end{itemize}

\textbf{Use cases:} Representing success/failure states, navigation events, UI state models.

\subsubsection{When to Use Each}

\begin{itemize}
  \item Use \textbf{enum class} when:
    \begin{itemize}
      \item You need a lightweight, fixed set of constants.
      \item You don’t need to associate much data with each value.
    \end{itemize}
  \item Use \textbf{sealed class} when:
    \begin{itemize}
      \item You need richer type hierarchies with state.
      \item You want to leverage exhaustiveness in \texttt{when} statements.
    \end{itemize}
\end{itemize}

\textbf{Focus Point:} Enums are simple and ideal for constant values. Sealed classes are more powerful for modeling domain hierarchies and UI or network state transitions.


\subsection{Kotlin Idioms}

\subsubsection{Scope Functions}

Kotlin's \textbf{scope functions} simplify code by providing a temporary context for an object. They improve readability, reduce boilerplate, and support safe operations like null-checks and initialization.

\paragraph{Overview Table}\mbox{}\\

\begin{tabular}{|l|c|c|p{6cm}|}
\hline
\textbf{Function} & \textbf{Context} & \textbf{Returns} & \textbf{Common Usage} \\
\hline
\texttt{let}   & \texttt{it}   & Lambda result     & Null checks, transformations, chaining \\
\texttt{run}   & \texttt{this} & Lambda result     & Object operations with result \\
\texttt{apply} & \texttt{this} & Context object    & Object configuration (builder pattern) \\
\texttt{also}  & \texttt{it}   & Context object    & Side-effects (e.g., logging, validation) \\
\texttt{with}  & \texttt{this} & Lambda result     & Scoped block for existing object \\
\hline
\end{tabular}

\paragraph{Examples}

\begin{lstlisting}[language=Kotlin]
// let: safe call with transformation
val email = user?.let { it.email.toLowerCase() }

// apply: configure object properties
val user = User().apply {
    name = "Anna"
    age = 25
}

// run: operate and return result
val greeting = user.run { "$name is $age years old" }

// also: side-effects
val saved = user.also { println("Saving: $it") }

// with: group operations on object
val desc = with(user) { "$name - $age" }
\end{lstlisting}

\paragraph{Usage Tips}

\begin{itemize}
  \item Use \texttt{let} for null-safe chains or temporary result transformation.
  \item Use \texttt{apply} when building or configuring an object.
  \item Use \texttt{also} to attach logging, validation, or tracking.
  \item Use \texttt{run} when you need to operate and return a result.
  \item Use \texttt{with} for scoped actions on already-available objects.
\end{itemize}

\textbf{Focus Point:} Choose the function based on context reference (\texttt{this} or \texttt{it}) and what the block should return (object or lambda result).

\subsubsection{Idiomatic Kotlin Usage Patterns}

\begin{itemize}
  \item Prefer \texttt{val} over \texttt{var} unless mutation is needed.
  \item Use \texttt{when} as a replacement for complex \texttt{if-else} chains.
  \item Use default arguments instead of method overloading.
  \item Leverage destructuring for pairs, triples, and data classes.
  \item Prefer immutability and expression-style code.
  \item Use \texttt{?} and \texttt{?:} (Elvis operator) for null-safe operations.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
fun greet(name: String = "Guest") = println("Hello, $name")

val person = getUser() ?: return
val (id, email) = person
\end{lstlisting}

\textbf{Focus Point:} Prefer idiomatic Kotlin constructs over Java-style patterns. Write expressive, concise, and safe code using features like null safety, extension functions, and coroutines.

\subsubsection{Destructuring and Smart Casts}

\paragraph{Destructuring Declarations}\mbox{}\\
Kotlin allows unpacking objects into multiple variables using destructuring. It improves readability and reduces boilerplate when dealing with data structures.

\textbf{Common use cases:}
\begin{itemize}
  \item Working with \texttt{data class} instances
  \item Iterating over key-value pairs in a \texttt{Map}
  \item Returning multiple values via \texttt{Pair}, \texttt{Triple}, or custom classes
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
data class User(val name: String, val age: Int)

val user = User("Alice", 25)
val (name, age) = user
println("$name is $age years old")
\end{lstlisting}

\textbf{Map iteration:}
\begin{lstlisting}[language=Kotlin]
val map = mapOf("a" to 1, "b" to 2)
for ((key, value) in map) {
    println("$key -> $value")
}
\end{lstlisting}

\paragraph{Smart Casts}\mbox{}\\
Kotlin automatically casts a variable to a target type if it has already been checked (e.g., with \texttt{is} or \texttt{!is}) and is immutable.

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
fun printLength(obj: Any) {
    if (obj is String) {
        // Smart cast to String
        println(obj.length)
    }
}
\end{lstlisting}

\textbf{Limitations:}
\begin{itemize}
  \item Works only on \texttt{val} (not \texttt{var}) or local variables
  \item Not applied if the variable can change between the check and usage
\end{itemize}

\textbf{Focus Point:} Smart casts reduce explicit casting. Destructuring makes data extraction cleaner and more idiomatic.


\subsection{Advanced Language Features}

Kotlin provides powerful language features that enhance type safety, performance, and expressiveness. Below are the key advanced constructs every developer should be familiar with.

\subsubsection{Kotlin Modifiers and Keywords}

\paragraph{\texttt{open}} Enables inheritance; by default, classes and functions are \texttt{final} in Kotlin.
\begin{lstlisting}[language=Kotlin]
open class Animal {
    open fun speak() = println("...")
}
\end{lstlisting}

\paragraph{\texttt{sealed}} Restricts subclassing to the same file, enabling exhaustive \texttt{when} statements.
\begin{lstlisting}[language=Kotlin]
sealed class Result
data class Success(val data: String): Result()
data class Error(val e: Throwable): Result()
\end{lstlisting}

\paragraph{\texttt{internal}} Restricts visibility to within the same module.

\paragraph{\texttt{inner}} Nested classes are static by default. Use \texttt{inner} to retain a reference to the outer class.
\begin{lstlisting}[language=Kotlin]
class Outer {
    inner class Inner {
        fun show() = println(this@Outer)
    }
}
\end{lstlisting}

\paragraph{\texttt{object}} Declares a singleton instance. Useful for stateless utility holders.
\begin{lstlisting}[language=Kotlin]
object Logger {
    fun log(msg: String) = println(msg)
}
\end{lstlisting}

\paragraph{\texttt{companion object}} Adds static-like members inside a class.
\begin{lstlisting}[language=Kotlin]
class Factory {
    companion object {
        fun create() = Factory()
    }
}
\end{lstlisting}

\paragraph{\texttt{lateinit}} Declares a non-null \texttt{var} to be initialized later (reference types only).
\begin{lstlisting}[language=Kotlin]
lateinit var repo: UserRepository
\end{lstlisting}

\paragraph{\texttt{lazy}, \texttt{by}} Lazy initializes a value only once when accessed.
\begin{lstlisting}[language=Kotlin]
val config by lazy { loadConfig() }
\end{lstlisting}

\paragraph{\texttt{expect} / \texttt{actual}} Used in multiplatform development to declare platform-specific implementations.

\paragraph{\texttt{infix}} Allows calling functions without dot and parentheses for single-parameter functions.
\begin{lstlisting}[language=Kotlin]
infix fun String.times(n: Int) = repeat(n)
val result = "Hello " times 3
\end{lstlisting}

\subsubsection{Inline, \texttt{reified}, \texttt{crossinline}}

\paragraph{\texttt{inline}} Inlines the function body at call site. Reduces overhead for small or performance-sensitive functions.

\paragraph{\texttt{reified}} Allows access to generic type info at runtime (only works in inline functions).
\begin{lstlisting}[language=Kotlin]
inline fun <reified T> isInstance(value: Any) = value is T
\end{lstlisting}

\paragraph{\texttt{crossinline}} Prevents non-local returns inside lambda passed to an inline function.
\begin{lstlisting}[language=Kotlin]
inline fun runTask(crossinline block: () -> Unit) {
    Thread { block() }.start()
}
\end{lstlisting}

\subsubsection{Operator Overloading}

Kotlin allows you to define custom behavior for operators by overloading predefined functions.

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point) = Point(x + other.x, y + other.y)
}

val result = Point(1, 2) + Point(3, 4)
\end{lstlisting}

\textbf{Common overloadable operators:}
\begin{itemize}
  \item \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%}
  \item \texttt{==}, \texttt{<}, \texttt{>}, \texttt{in}, \texttt{!in}
  \item Index access: \texttt{get()}, \texttt{set()}
  \item Invoke: \texttt{invoke()}
\end{itemize}

\subsubsection{Exception Handling}

Kotlin's exception handling is similar to Java, but there are key differences:

\begin{itemize}
  \item No distinction between checked and unchecked exceptions.
  \item Use \texttt{try/catch/finally} blocks.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
try {
    riskyOperation()
} catch (e: IOException) {
    println("Caught IOException: ${e.message}")
} finally {
    println("Cleanup")
}
\end{lstlisting}

\textbf{Focus Point:} Kotlin improves expressiveness with keywords like \texttt{reified}, \texttt{infix}, and \texttt{sealed}. Know when to use them for better abstraction, runtime safety, and clean DSLs.


\subsection{Collections \& Functional APIs}

Kotlin collections provide a rich set of operators and are split into mutable and immutable variants. Functional APIs like \texttt{map}, \texttt{filter}, and \texttt{reduce} are used to process data in a concise and expressive way.

\subsubsection{map, filter, reduce}

\paragraph{\texttt{map}}  
Transforms each element in the collection using the lambda expression.
\begin{lstlisting}[language=Kotlin]
val doubled = listOf(1, 2, 3).map { it * 2 } // [2, 4, 6]
\end{lstlisting}

\paragraph{\texttt{filter}}  
Returns a new list containing only the elements that match the condition.
\begin{lstlisting}[language=Kotlin]
val evens = listOf(1, 2, 3, 4).filter { it % 2 == 0 } // [2, 4]
\end{lstlisting}

\paragraph{\texttt{reduce}}  
Combines all elements into a single value using an accumulator function.
\begin{lstlisting}[language=Kotlin]
val sum = listOf(1, 2, 3).reduce { acc, i -> acc + i } // 6
\end{lstlisting}

\textbf{Focus Point:} Use these functions to write expressive, functional-style code. Prefer \texttt{fold} over \texttt{reduce} when an initial value is needed.

\subsubsection{Immutable Collections}

Kotlin distinguishes between read-only (immutable) and mutable collections:

\begin{itemize}
  \item \texttt{listOf()}, \texttt{setOf()}, \texttt{mapOf()} → Immutable
  \item \texttt{mutableListOf()}, \texttt{mutableSetOf()}, \texttt{mutableMapOf()} → Mutable
\end{itemize}

\begin{lstlisting}[language=Kotlin]
val list = listOf("a", "b", "c")      // cannot modify
val mutable = mutableListOf("x", "y")
mutable.add("z")                      // allowed
\end{lstlisting}

\textbf{Focus Point:} Read-only does not guarantee immutability — it only exposes a restricted interface. Internally, the data may still be mutable if references are shared.


\section{Kotlin Coroutines}

Kotlin coroutines simplify asynchronous programming by allowing code to be written sequentially while executing non-blocking operations under the hood. They are based on suspendable computations, managed via structured concurrency.

\subsection{Core Concepts}

\subsubsection{What Are Coroutines?}
Coroutines are lightweight, suspendable computations that allow asynchronous, non-blocking code. Unlike threads, they are managed by the Kotlin runtime and can be paused/resumed without blocking.

\subsubsection{suspend Functions}

A \texttt{suspend} function in Kotlin is a special function that can \textbf{pause its execution} without blocking the current thread, and later \textbf{resume} from the same point. It is a key building block of coroutines.

\texttt{suspend} functions must be invoked from another \texttt{suspend} function or a coroutine scope.

\begin{lstlisting}[language=Kotlin]
suspend fun loadData() {
    delay(1000) // suspends without blocking the thread
    println("Loaded!")
}
\end{lstlisting}

\paragraph{How It Works Under the Hood}

When the compiler sees a \texttt{suspend} function, it transforms it into a \textbf{state machine} using a special object called a \texttt{Continuation}. Here's what happens:

\begin{itemize}
  \item The Kotlin compiler generates a class that implements the \texttt{Continuation} interface.
  \item Every suspension point (e.g., \texttt{delay()}, \texttt{withContext()}) splits the function into states.
  \item The current state and local variables are stored inside the continuation.
  \item When the suspension resumes, the continuation invokes the next state.
\end{itemize}

This mechanism enables pausing and resuming logic \textbf{without blocking any threads}, making Kotlin coroutines extremely lightweight.

\textbf{Focus Point:} A \texttt{suspend} function is just syntactic sugar over a callback-based state machine. Its power lies in how naturally it composes with other coroutine functions.

\paragraph{Key Rules of suspend Functions}
\begin{itemize}
  \item Can only be called from another \texttt{suspend} function or inside a coroutine block.
  \item Cannot be called from Java directly unless wrapped.
  \item Do not block threads — they use continuations to resume asynchronously.
\end{itemize}

\paragraph{Common suspend Functions}
\begin{itemize}
  \item \texttt{delay(ms)} — suspends for a specified time.
  \item \texttt{withContext(dispatcher)} — changes the coroutine context.
  \item Any network/database API built with coroutines (e.g., Retrofit, Room).
\end{itemize}

\paragraph{Example:}

\begin{lstlisting}[language=Kotlin]
fun fetchDataAsync() = CoroutineScope(Dispatchers.IO).launch {
    val result = getData() // getData is suspend
    withContext(Dispatchers.Main) {
        updateUI(result)
    }
}
\end{lstlisting}

\textbf{Deep Dive:} The Kotlin compiler generates bytecode for \texttt{suspend} functions using \texttt{invokeSuspend()} and continuation labels to switch between states — similar to how a manual switch-case state machine would work.

\subsubsection{CoroutineScope and Job}

\texttt{CoroutineScope} defines the lifecycle and structured environment in which coroutines run. It combines a \texttt{CoroutineContext}, which contains important coroutine configuration: typically a \texttt{Job} (for lifecycle) and a \texttt{Dispatcher} (for threading).

\paragraph{What is a CoroutineScope?}

A \texttt{CoroutineScope} provides the context for launching coroutines. When a coroutine is launched inside a scope, it inherits the scope's context and becomes part of its lifecycle.

\begin{lstlisting}[language=Kotlin]
val scope = CoroutineScope(Dispatchers.IO + Job())

scope.launch {
    // runs in IO thread and is cancellable via the parent Job
}
\end{lstlisting}

\paragraph{What is CoroutineContext?}

\texttt{CoroutineContext} is a key-value map that stores coroutine configuration. It's made up of:
\begin{itemize}
  \item \textbf{Job:} represents the coroutine lifecycle and cancellation.
  \item \textbf{Dispatcher:} determines the thread on which the coroutine runs (\texttt{Main}, \texttt{IO}, \texttt{Default}).
  \item \textbf{Name (optional):} for debugging.
  \item \textbf{ExceptionHandler (optional):} to catch uncaught exceptions.
\end{itemize}

\paragraph{What is a Job?}

A \texttt{Job} represents a coroutine's lifecycle handle — it can be active, completed, or cancelled. It also supports structured concurrency.

\begin{itemize}
  \item Cancelling a \texttt{Job} cancels all child coroutines.
  \item \texttt{Job} status can be queried: \texttt{isActive}, \texttt{isCompleted}, \texttt{isCancelled}.
  \item A \texttt{Job} can be created explicitly and added to a \texttt{CoroutineScope}.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
val job = Job()
val scope = CoroutineScope(Dispatchers.Default + job)

job.cancel() // cancels all child coroutines
\end{lstlisting}

\paragraph{Job Hierarchy and Structured Concurrency}

Kotlin enforces \textbf{structured concurrency}: child coroutines are tied to their parent \texttt{Job}. If the parent is cancelled, all children are cancelled recursively.

\begin{lstlisting}[language=Kotlin]
val parentScope = CoroutineScope(Job())

parentScope.launch {
    launch {
        delay(1000)
        println("Child coroutine")
    }
    delay(500)
    println("Cancelling parent")
    this.cancel() // cancels both coroutines
}
\end{lstlisting}

\textbf{Deep Dive:} Structured concurrency ensures that you don't accidentally leak coroutines. A child coroutine cannot outlive its parent scope, preventing memory leaks and unbounded job hierarchies.

\paragraph{SupervisorJob}

In some cases, you may want child coroutines to fail independently. \texttt{SupervisorJob} allows child failures without cancelling siblings.

\begin{lstlisting}[language=Kotlin]
val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

scope.launch {
    launch { throw RuntimeException("Fail") }
    launch { delay(1000); println("Still running") }
}
\end{lstlisting}

\textbf{Focus Point:} A \texttt{CoroutineScope} = \texttt{Job} + \texttt{Dispatcher} + (optional) handlers. You should always cancel scopes you own (e.g., in custom classes) to avoid leaking coroutines.

\paragraph{NonCancellable}

In certain cases, you may want to run cleanup or critical operations that should not be interrupted — even if the coroutine’s parent job is cancelled. Kotlin provides the \texttt{NonCancellable} context for this purpose.

\texttt{NonCancellable} is a special \texttt{CoroutineContext} element that disables cancellation inside its block.

\textbf{Typical use case:} ensuring that important cleanup code (e.g., saving to disk, closing a database) completes even if the coroutine is cancelled.

\begin{lstlisting}[language=Kotlin]
scope.launch {
    try {
        fetchData()
    } finally {
        withContext(NonCancellable) {
            saveToDisk() // runs even if coroutine was cancelled
        }
    }
}
\end{lstlisting}

\textbf{Important:} Use \texttt{NonCancellable} only for short, essential operations. Overusing it may block structured cancellation and cause delays in releasing resources.

\textbf{Focus Point:} Use \texttt{NonCancellable} in \texttt{finally} blocks when you need to guarantee cleanup or logging, regardless of coroutine cancellation.


\subsubsection{Dispatchers}

\texttt{Dispatchers} are a core part of the \texttt{CoroutineContext} and define the thread or thread pool on which a coroutine runs. They are used to control concurrency and switch execution between threads when needed.

Each coroutine runs with a specific \texttt{CoroutineContext}, and the \texttt{Dispatcher} is the element responsible for dispatching coroutine execution to a particular thread or pool.

\paragraph{Main Dispatchers in Kotlin:}

\begin{itemize}
  \item \textbf{\texttt{Dispatchers.Main}}  
  Executes coroutines on the main (UI) thread.  
  \textbf{Use case:} updating UI elements in Android.  
  Requires a dependency like \texttt{kotlinx-coroutines-android}.

  \textbf{Note:} This is single-threaded.

  \item \textbf{\texttt{Dispatchers.IO}}  
  Optimized for I/O operations: disk access, file read/write, network calls, database queries.  
  Internally backed by a shared thread pool with a higher thread cap than \texttt{Default}.

  \textbf{Thread pool:} dynamically grows based on load (unlimited).

  \item \textbf{\texttt{Dispatchers.Default}}  
  Designed for CPU-bound tasks: sorting, parsing, computations.  
  Backed by a shared pool with as many threads as CPU cores.

  \textbf{Thread pool:} \texttt{Runtime.getRuntime().availableProcessors()}.

  \item \textbf{\texttt{Dispatchers.Unconfined}}  
  Starts coroutine in the current call frame (no specific thread), resumes in the thread of the last suspension point.  
  \textbf{Use case:} testing, coroutine builders inside suspend functions.  

  \textbf{Note:} Not suitable for structured concurrency or UI code.

\end{itemize}

\paragraph{Custom Dispatchers}
You can create your own dispatcher using a \texttt{Executor} or \texttt{ThreadPoolExecutor} and converting it via \texttt{asCoroutineDispatcher()}:

\begin{lstlisting}[language=Kotlin]
val myDispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher()
\end{lstlisting}

Useful when strict control over threading behavior or performance is needed (e.g., for background queues or custom lifecycle dispatching).

\textbf{Focus Point:}  
Dispatchers help you separate UI work from background logic. Always switch to \texttt{Dispatchers.Main} when interacting with UI, and use \texttt{IO} or \texttt{Default} depending on whether your task is I/O or CPU intensive.

\textbf{Deep Dive:}  
All Dispatchers are part of the coroutine context — combined via \texttt{+} with elements like \texttt{Job}. When launching a coroutine, its context determines both the dispatcher (thread) and the parent job (lifecycle).


\subsubsection{Exception Handling in Coroutines}

Exception handling in coroutines depends on the coroutine \textbf{builder} used and follows different propagation rules compared to regular try-catch blocks in threads. Understanding this behavior is essential to writing safe concurrent code.

\paragraph{1. Exception Behavior by Builder Type}
\begin{itemize}
  \item \texttt{\textbf{launch}}: Exceptions are \textbf{immediately propagated} to the \texttt{CoroutineExceptionHandler}. If uncaught, they cancel the coroutine’s parent.
  \item \texttt{\textbf{async}}: Exceptions are \textbf{deferred} and thrown only when \texttt{await()} is called. If not awaited, the exception may be silently ignored.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
// launch with handler
val handler = CoroutineExceptionHandler { _, e -> 
    println("Caught in handler: $e")
}

scope.launch(handler) {
    throw RuntimeException("Boom!")
}

// async with try-catch
val deferred = scope.async {
    throw IllegalStateException("Async failed")
}
try {
    deferred.await()
} catch (e: Exception) {
    println("Caught async exception: $e")
}
\end{lstlisting}

\paragraph{2. CoroutineExceptionHandler}
A \texttt{CoroutineExceptionHandler} is a special element of the coroutine context used to handle uncaught exceptions from \texttt{launch} coroutines.

\begin{itemize}
  \item Only works with \texttt{launch} (not \texttt{async}).
  \item It's invoked \textbf{after the coroutine has failed}.
  \item Acts like a global fallback if no try-catch is present inside the coroutine.
\end{itemize}

\paragraph{3. Exception Propagation in Hierarchy}
Coroutines follow \textbf{structured concurrency}. If a child coroutine throws an uncaught exception, its parent is cancelled. This can propagate upward.

\begin{lstlisting}[language=Kotlin]
val parent = CoroutineScope(Job())

parent.launch {
    launch {
        throw RuntimeException("child error")
    }
    // This coroutine is also cancelled
    launch {
        delay(1000)
        println("Never printed")
    }
}
\end{lstlisting}

\textbf{Key point:} all children are cancelled if one fails (unless using a \texttt{SupervisorJob}).

\paragraph{4. SupervisorJob for Independent Failures}
\texttt{SupervisorJob} prevents failure in one child from cancelling its siblings.

\begin{lstlisting}[language=Kotlin]
val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

scope.launch {
    launch {
        throw RuntimeException("This fails")
    }
    launch {
        delay(500)
        println("Still runs")
    }
}
\end{lstlisting}

\paragraph{5. Try-Catch in Suspend Functions}
Exceptions inside \texttt{suspend} functions should be handled explicitly. Wrapping coroutine calls in try-catch is a best practice when no handler is available.

\begin{lstlisting}[language=Kotlin]
suspend fun riskyOperation() {
    // can throw
}

scope.launch {
    try {
        riskyOperation()
    } catch (e: Exception) {
        log("Handled: ${e.message}")
    }
}
\end{lstlisting}

\textbf{Focus Point:} Use \texttt{CoroutineExceptionHandler} for top-level \texttt{launch}, and wrap risky calls in \texttt{try-catch} for precise control. Remember that \texttt{async} must always be awaited to handle exceptions properly.

\textbf{Deep Dive:}  
In Kotlin's coroutine machinery, exceptions are stored in a continuation's state until resumed. The coroutine builder determines if the continuation resumes with success or failure — this distinction explains why \texttt{launch} surfaces errors immediately, while \texttt{async} encapsulates them in \texttt{Deferred}.

\subsubsection{Job Hierarchy and Structured Concurrency}

Every coroutine is associated with a \texttt{Job}, which acts as a handle to manage its lifecycle. Jobs are part of the coroutine context and form a parent-child hierarchy, enabling \textbf{structured concurrency} — a mechanism to manage cancellation, failure propagation, and cleanup in a predictable and safe way.

\paragraph{Key Concepts}

\begin{itemize}
  \item A \textbf{Job} is a cancellable unit of work. It can be in different states: \texttt{New}, \texttt{Active}, \texttt{Completing}, \texttt{Cancelled}, or \texttt{Completed}.
  \item A parent job keeps references to all its children. If the parent is cancelled or fails, all its children are automatically cancelled.
  \item Child jobs can report their failure to the parent. If any child fails (unless supervised), it cancels the parent and all siblings.
\end{itemize}

\paragraph{State Diagram (simplified)}

\begin{center}
\texttt{New} $\rightarrow$ \texttt{Active} $\rightarrow$ \texttt{Completing} $\rightarrow$ \texttt{Completed} \\
\hspace{3.5cm} $\searrow$ \texttt{Cancelled}
\end{center}

\texttt{Job} state is observable and can be checked with:
\begin{itemize}
  \item \texttt{job.isActive} — still running or about to run
  \item \texttt{job.isCancelled} — cancelled but not yet completed
  \item \texttt{job.isCompleted} — terminal state (success or failure)
\end{itemize}

\paragraph{Example: Parent Cancels Children}\mbox{}\\
\begin{lstlisting}[language=Kotlin]
val parent = CoroutineScope(Job())

parent.launch {
    launch {
        delay(1000)
        println("This won't print — child is cancelled")
    }
    delay(100)
    println("Cancelling parent")
    this.cancel() // cancels all children
}
\end{lstlisting}

\paragraph{SupervisorJob: Isolating Failure}
To prevent child failure from cancelling the parent and siblings, use \texttt{SupervisorJob}. Each child runs independently.

\begin{lstlisting}[language=Kotlin]
val scope = CoroutineScope(SupervisorJob())

scope.launch {
    launch {
        throw RuntimeException("Boom")
    }
    launch {
        delay(500)
        println("This still runs")
    }
}
\end{lstlisting}

\paragraph{Structured Concurrency: Scope Owns Job}
A \texttt{CoroutineScope} combines a \texttt{Job} with a \texttt{CoroutineContext}. All coroutines launched from that scope inherit the same parent job:

\begin{lstlisting}[language=Kotlin]
val scope = CoroutineScope(Dispatchers.IO + Job())

val job = scope.launch {
    doSomething()
}
\end{lstlisting}

When the scope is cancelled, all jobs and sub-jobs are recursively cancelled.

\paragraph{Focus Point:} Job hierarchy ensures predictable cleanup and lifecycle management. Cancellation flows from parent to child unless isolated with \texttt{SupervisorJob}.

\paragraph{Deep Dive: How Propagation Works}
Internally, a job tracks its state and maintains a list of child jobs. When a job completes or fails, it triggers its registered completion handlers and notifies its parent (if any).

Each job has a \texttt{ParentHandle}, which listens for cancellation or completion of the parent. On failure:
\begin{itemize}
  \item If not a \texttt{SupervisorJob}, the parent is cancelled.
  \item Cancellation is propagated downward, recursively cancelling all children.
\end{itemize}

\paragraph{Non-cancellable jobs}
You can use \texttt{NonCancellable} to prevent a coroutine from being cancelled — e.g., during cleanup:

\begin{lstlisting}[language=Kotlin]
withContext(NonCancellable) {
    saveToDisk() // won't be interrupted
}
\end{lstlisting}

\paragraph{Best Practice}
Always launch coroutines in a structured scope (e.g., \texttt{viewModelScope}, \texttt{lifecycleScope}, or an explicit \texttt{CoroutineScope}) to benefit from proper cancellation, cleanup, and predictable behavior.

\subsubsection{Cancellation}

Coroutine cancellation is an essential part of structured concurrency in Kotlin. It ensures that operations can be stopped gracefully when no longer needed — for example, when a user leaves a screen or a network call times out.

\paragraph{What Is Cancellation?}

Cancellation in Kotlin coroutines is \textbf{cooperative}: a coroutine does not stop immediately when \texttt{cancel()} is called on its \texttt{Job}. Instead, it must periodically check its cancellation status and stop execution voluntarily.

\paragraph{How Cancellation Works Internally}

When a coroutine is cancelled, its \texttt{Job} enters the \texttt{Cancelling} state. This:

\begin{itemize}
  \item Triggers any \texttt{invokeOnCompletion} handlers.
  \item Propagates cancellation to all child jobs.
  \item Makes \texttt{isActive} return \texttt{false}.
  \item Causes most \textbf{suspending functions} (like \texttt{delay()}, \texttt{withContext()}, etc.) to throw a \texttt{CancellationException}.
\end{itemize}

However, \textbf{non-suspending, long-running code} (like tight \texttt{while} loops) won’t be cancelled unless they explicitly check for \texttt{isActive}.

\paragraph{Example: Cooperative Cancellation}\mbox{}\\

\begin{lstlisting}[language=Kotlin]
val job = scope.launch {
    while (isActive) {
        doWork()
        delay(100) // This will throw CancellationException if cancelled
    }
}
job.cancel() // Requests cancellation
\end{lstlisting}

\paragraph{Why Cooperative Cancellation Is Important}

If you don't support cancellation properly:
\begin{itemize}
  \item Your coroutine might continue running in the background unnecessarily, wasting memory and CPU.
  \item It may hold onto references (like Contexts or Views), causing memory leaks.
  \item It breaks structured concurrency, violating the guarantee that children die with the parent.
\end{itemize}

\paragraph{Handling Cancellation with \texttt{try-finally}}

To ensure cleanup happens even after cancellation, use a \texttt{try-finally} block:

\begin{lstlisting}[language=Kotlin]
val job = scope.launch {
    try {
        repeat(1000) {
            println("Working $it")
            delay(100)
        }
    } finally {
        println("Cleaning up after cancellation")
    }
}
delay(500)
job.cancel()
\end{lstlisting}

\paragraph{Using \texttt{ensureActive()}}

You can explicitly check for cancellation in code that doesn’t use suspending functions:

\begin{lstlisting}[language=Kotlin]
fun heavyLoopComputation(scope: CoroutineScope) {
    for (i in 1..1_000_000) {
        scope.ensureActive() // throws CancellationException if needed
        compute(i)
    }
}
\end{lstlisting}

\paragraph{NonCancellable Cleanup}

\texttt{NonCancellable} is a special coroutine context used to bypass cancellation. It is required when cleanup logic must complete even if the parent coroutine was cancelled.

\begin{lstlisting}[language=Kotlin]
withContext(NonCancellable) {
    persistToDisk()
}
\end{lstlisting}

\textbf{Focus Point:} Use \texttt{NonCancellable} only in \texttt{finally} blocks where skipping logic is unsafe.

\textbf{Deep Dive:}  
\texttt{NonCancellable} is a singleton \texttt{Job} that is always active and not attached to the parent coroutine's job. Since it is not a child, cancellation signals are not propagated to it.

Internally:
\begin{lstlisting}[language=Kotlin]
object NonCancellable : Job {
    override val isActive: Boolean get() = true
    override fun cancel(...) = Unit
    // ...
}
\end{lstlisting}

This breaks structured concurrency but ensures the block runs to completion unless the process is killed.


\paragraph{Focus Point:} Coroutine cancellation is cooperative and must be respected. Always check \texttt{isActive} or use cancellable suspend functions to prevent resource leaks and hanging jobs.

\paragraph{Deep Dive: What Happens on \texttt{cancel()}}

Calling \texttt{job.cancel()}:
\begin{itemize}
  \item Sets the job state to \texttt{Cancelling}.
  \item Cancels all child jobs recursively.
  \item Cancels the \texttt{CoroutineContext} (including dispatchers if needed).
  \item Triggers \texttt{CancellationException} in ongoing suspension points.
  \item Finishes with state \texttt{Cancelled} or \texttt{Completed}.
\end{itemize}

The coroutine will then terminate once all finally blocks are completed.

\subsubsection{Benefits of Coroutines}

Kotlin coroutines offer significant advantages in managing concurrency and asynchronous workflows compared to traditional threading, callbacks, or even RxJava.

\begin{itemize}
  \item \textbf{Lightweight Threads}:  
  Coroutines are not threads — they are managed by the Kotlin runtime and can be multiplexed across a small thread pool. You can launch thousands of coroutines without exhausting memory or CPU, unlike threads which are OS-level and expensive.

  \item \textbf{Structured Concurrency}:  
  Coroutines launched in a \texttt{CoroutineScope} are bound to the scope's lifecycle. This means child coroutines are automatically cancelled with their parent, avoiding leaks and uncontrolled background work.

  \item \textbf{Sequential Syntax, Asynchronous Behavior}:  
  Coroutines allow writing asynchronous code that looks and behaves like synchronous code. This improves readability, reduces indentation hell, and eliminates callback nesting (\textit{callback hell}).

  \item \textbf{Dispatcher Control}:  
  You explicitly control the thread context with \texttt{Dispatchers.Main}, \texttt{Dispatchers.IO}, etc., allowing seamless switching between UI, I/O, and CPU-bound work — all within the same coroutine.

  \item \textbf{Built-in Cancellation}:  
  Jobs support cooperative cancellation out of the box. This makes it easy to terminate operations safely and consistently when no longer needed (e.g., screen destroyed, request timed out).

  \item \textbf{Error Propagation and Supervision}:  
  Coroutines support hierarchical error handling. Exceptions automatically bubble up to the parent job (with \texttt{launch}) or are deferred in \texttt{async}, enabling centralized and predictable failure recovery.

  \item \textbf{Deep Integration with Jetpack}:  
  Coroutines integrate natively with many Jetpack components:
  \begin{itemize}
    \item \texttt{Room} for suspend database queries.
    \item \texttt{Retrofit} for suspend API calls.
    \item \texttt{LiveData}/\texttt{Flow} for observable state and event streams.
    \item \texttt{ViewModelScope}/\texttt{LifecycleScope} for lifecycle-safe coroutines.
  \end{itemize}
\end{itemize}

\textbf{Focus Point:}  
Coroutines combine the simplicity of sequential programming with the efficiency of asynchronous systems. They’re safer than threads, easier than callbacks, and lighter than RxJava.


\subsection{Usage Patterns}

\subsubsection{launch vs async}

Kotlin provides two main coroutine builders: \texttt{launch} and \texttt{async}. Understanding their differences is crucial for writing correct and efficient concurrent code.

\paragraph{\texttt{launch}} — Fire-and-forget execution

\begin{itemize}
  \item Returns a \texttt{Job}.
  \item Does not return a result.
  \item Commonly used for side-effects: UI updates, logging, or background tasks.
  \item Exceptions are propagated \textbf{immediately} and can be handled by a \texttt{CoroutineExceptionHandler}.
  \item Automatically completes unless explicitly cancelled or an exception is thrown.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
scope.launch {
    updateUi()
    log("Done")
}
\end{lstlisting}

\paragraph{\texttt{async}} — Concurrent computation with result

\begin{itemize}
  \item Returns a \texttt{Deferred<T>}, which represents a future value.
  \item Must call \texttt{await()} to get the result or propagate exceptions.
  \item Ideal for parallel computation, API calls, or when combining multiple async results.
  \item Exceptions are \textbf{deferred} until \texttt{await()} is invoked.
  \item If \texttt{await()} is forgotten, errors are silently ignored — a common pitfall.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
val deferred = scope.async {
    computeSomething()
}
val result = deferred.await()
\end{lstlisting}

\paragraph{Comparison Table}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|l|}
\hline
 & \texttt{launch} & \texttt{async} \\
\hline
Returns & \texttt{Job} & \texttt{Deferred<T>} \\
Return Value & None & Yes (via \texttt{await()}) \\
Use Case & Side-effects & Parallel computation \\
Error Handling & Immediate (via handler) & Deferred (on \texttt{await()}) \\
Common Pitfall & Missing error handler & Forgetting to \texttt{await()} \\
\hline
\end{tabular}
\end{table}

\paragraph{Common Misconception:}  
\texttt{async} is not inherently better than \texttt{launch}. If no result is needed, prefer \texttt{launch} — it’s simpler and lighter.

\paragraph{Deep Dive: Structured Concurrency}  
Both \texttt{launch} and \texttt{async} respect structured concurrency. They inherit the \texttt{Job} from their scope and are automatically cancelled if the parent is cancelled.

\paragraph{Focus Point:}  
Use \texttt{launch} for fire-and-forget side effects. Use \texttt{async} when you need a result — but always remember to call \texttt{await()}.

\subsubsection{Lifecycle-aware Scopes: \texttt{viewModelScope}, \texttt{lifecycleScope}}

In Android, coroutines must be tied to component lifecycles to avoid leaks and crashes. Jetpack provides lifecycle-aware scopes that automatically cancel coroutines when the related component is destroyed.

\paragraph{\texttt{viewModelScope}}

\texttt{viewModelScope} is tied to the lifecycle of a \texttt{ViewModel}. When the ViewModel is cleared (e.g., when the user navigates away or the configuration changes), all launched coroutines are automatically cancelled.

\begin{lstlisting}[language=Kotlin]
class MyViewModel : ViewModel() {
    fun loadData() {
        viewModelScope.launch {
            val result = repository.fetchData()
            _uiState.value = result
        }
    }
}
\end{lstlisting}

\paragraph{\texttt{lifecycleScope}}

\texttt{lifecycleScope} is tied to the lifecycle of an \texttt{Activity} or \texttt{Fragment} (i.e., any \texttt{LifecycleOwner}). Coroutines launched in this scope are cancelled automatically when the lifecycle reaches the \texttt{DESTROYED} state.

\begin{lstlisting}[language=Kotlin]
class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch {
            val data = repository.fetchData()
            updateUI(data)
        }
    }
}
\end{lstlisting}

\paragraph{Why it matters:}

Without lifecycle-aware scopes, developers often had to manually cancel coroutines in \texttt{onStop()} or \texttt{onDestroy()}, which is error-prone. These scopes:
\begin{itemize}
  \item Prevent memory leaks caused by long-running background work.
  \item Avoid UI crashes due to invalid view references after the component is gone.
  \item Simplify code by removing the need for manual cancellation.
\end{itemize}

\paragraph{How it works internally:}
Both \texttt{viewModelScope} and \texttt{lifecycleScope} are wrappers around a \texttt{CoroutineScope} initialized with:
\begin{itemize}
  \item A default \texttt{Dispatchers.Main.immediate} dispatcher.
  \item A \texttt{Job} that is cancelled when the component's lifecycle ends.
\end{itemize}

\paragraph{Deep Dive: Scope Lifecycle Tie-ins}

\begin{itemize}
  \item \texttt{viewModelScope} cancels its coroutines in \texttt{ViewModel.onCleared()}.
  \item \texttt{lifecycleScope} observes the \texttt{LifecycleOwner} and cancels when state is \texttt{DESTROYED}.
  \item Use \texttt{repeatOnLifecycle()} or \texttt{launchWhenStarted()} to limit coroutine execution to specific states (e.g., only when the UI is visible).
\end{itemize}

\textbf{Example with limited lifecycle:}
\begin{lstlisting}[language=Kotlin]
lifecycleScope.launch {
    repeatOnLifecycle(Lifecycle.State.STARTED) {
        viewModel.stateFlow.collect {
            updateUI(it)
        }
    }
}
\end{lstlisting}

\paragraph{Focus Point:}  
Always use \texttt{viewModelScope} or \texttt{lifecycleScope} to launch coroutines in UI code. They automatically handle cancellation and are critical to avoid leaking background work tied to dead views or destroyed activities.


\subsection{Kotlin Flow}
\label{subsec:kotlin_flow}

\subsubsection{What Is Flow}

\texttt{Flow} is a cold asynchronous data stream built on top of Kotlin coroutines. It allows emitting multiple values sequentially over time and is fully integrated with coroutine primitives like \texttt{suspend}, \texttt{CoroutineContext}, cancellation, and structured concurrency.

\texttt{Flow} provides a declarative API for working with reactive data — like RxJava but simpler and coroutine-native.

\begin{lstlisting}[language=Kotlin]
val numbers = flow {
    for (i in 1..5) {
        delay(500)
        emit(i)
    }
}
\end{lstlisting}

\texttt{Flow} is \textbf{cold} by default: the block is re-executed for each collector, and emissions start only when the flow is actively collected.

\begin{lstlisting}[language=Kotlin]
numbers.collect { println(it) } // Starts the flow
\end{lstlisting}

\paragraph{Why Flow?}
\begin{itemize}
  \item Clean replacement for callbacks, RxJava, and even \texttt{LiveData}.
  \item Suspend-friendly and cancellation-aware.
  \item Type-safe and natively integrated with coroutines.
\end{itemize}

\textbf{Focus Point:} \texttt{Flow} lets you model event or data streams in a way that's consistent with coroutine principles — it's composable, structured, and cooperative.

\subsubsection{Cold vs Hot Streams}

\begin{itemize}
  \item \textbf{Cold Flow}: starts fresh for every collector. Best for data streams like database queries, network calls, and algorithmic pipelines.
  \item \textbf{Hot Flow}: actively emits values regardless of collectors. Best for sharing UI state or broadcasting events.
\end{itemize}

\subsubsection{How Flows Work Internally}

A \texttt{Flow} is essentially a suspendable finite state machine. Under the hood, each emitted value is encapsulated in a continuation. When the collector suspends (e.g., using \texttt{delay()}), the flow suspends execution until resumed.

\paragraph{Coroutine Context Integration}
When you collect a flow, a coroutine is launched with a \texttt{CoroutineContext} (which includes dispatcher, job, etc.). Cancellation propagates automatically via cooperative checks inside \texttt{emit()} and \texttt{collect()}.

\paragraph{Flow Builder Configuration}
The \texttt{flow} builder allows configuration via these operators:

\begin{itemize}
  \item \texttt{flowOn(context)} – Changes the upstream dispatcher.
  \item \texttt{catch \{ \}} – Handles exceptions in the flow.
  \item \texttt{onStart \{ \}}, \texttt{onEach \{ \}}, \texttt{onCompletion \{ \}} – Lifecycle events.
  \item \texttt{buffer()}, \texttt{conflate()}, \texttt{debounce()} – Backpressure and rate control.
  \item \texttt{collectLatest()} – Cancels and restarts collection on new emissions.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
flow {
    emit(loadFromDisk())
    emit(loadFromNetwork())
}.flowOn(Dispatchers.IO)
 .catch { emit(emptyList()) }
 .onStart { showLoading() }
 .collect { showResult(it) }
\end{lstlisting}

\textbf{Focus Point:} Use \texttt{flowOn} to shift the context upstream without affecting the downstream collector. Think of it as controlling the production thread.

\subsubsection{StateFlow, SharedFlow and Channel}

\paragraph{StateFlow}
\texttt{StateFlow} is a hot flow that always has a current value. It is ideal for UI state:

\begin{itemize}
  \item Only emits updates when the state changes.
  \item Always has a value — acts like a \texttt{BehaviorSubject}.
  \item Use \texttt{MutableStateFlow} in ViewModel and expose as \texttt{StateFlow}.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
private val _uiState = MutableStateFlow(Loading)
val uiState: StateFlow<UiState> = _uiState
\end{lstlisting}

\paragraph{SharedFlow}
\texttt{SharedFlow} is for one-time events like navigation, toasts, analytics. It supports:

\begin{itemize}
  \item Replay for late subscribers.
  \item Buffer overflow strategies.
  \item Multiple concurrent collectors.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
private val _events = MutableSharedFlow<UiEvent>(
    replay = 0, extraBufferCapacity = 1
)
val events = _events.asSharedFlow()
\end{lstlisting}

\paragraph{Channel}
A \texttt{Channel} is a coroutine-based queue for one-to-one communication:

\begin{itemize}
  \item Not lifecycle-safe by default.
  \item Use when you need suspending send/receive (like pipelines).
  \item Less structured — prefer \texttt{SharedFlow} for UI events.
\end{itemize}

\textbf{Deep Dive:}
Use \texttt{channelFlow} builder to emit from multiple coroutines in parallel:

\begin{lstlisting}[language=Kotlin]
fun multiFlow(): Flow<Int> = channelFlow {
    launch { send(1) }
    launch { send(2) }
}
\end{lstlisting}

\textbf{Deep Dive:}
\begin{table}[h!]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Type} & \textbf{Cold/Hot} & \textbf{Keeps Last Value} & \textbf{Supports Multiple Collectors} \\
\hline
\texttt{Flow} & Cold & No & No \\
\texttt{StateFlow} & Hot & Yes & Yes \\
\texttt{SharedFlow} & Hot & No (or replayed) & Yes \\
\texttt{Channel} & Hot & No & No (1-to-1) \\
\hline
\end{tabular}
\caption{Flow Variants and Use Cases}
\end{table}

\subsubsection{Flow vs LiveData}

\textbf{Key Differences:}

\begin{itemize}
  \item \texttt{LiveData} is tightly coupled to Android lifecycle; \texttt{Flow} is platform-agnostic.
  \item \texttt{LiveData} is always hot; \texttt{Flow} is cold by default.
  \item \texttt{Flow} supports all coroutine operators (\texttt{map}, \texttt{flatMap}, \texttt{catch}, \texttt{combine}).
  \item Lifecycle integration with \texttt{Flow} requires \texttt{repeatOnLifecycle()} or \texttt{lifecycleScope}.
\end{itemize}

\textbf{Focus Point:} Use \texttt{LiveData} only in legacy code or with XML data binding. Prefer \texttt{StateFlow} or \texttt{SharedFlow} in modern coroutine-based apps.

\subsubsection{Typical Use Cases}

\begin{itemize}
  \item \texttt{Flow}: loading paginated data, network chaining.
  \item \texttt{StateFlow}: view state (e.g., loading, success, error).
  \item \texttt{SharedFlow}: navigation, dialogs, snackbar events.
  \item \texttt{Channel}: advanced messaging between coroutines.
\end{itemize}

\textbf{Focus Point:} Flows unify async, reactive, and state-handling paradigms under a single, structured, coroutine-native API.


\section{Jetpack Compose}
\label{sec:what_is_compose}

\subsection{What is Jetpack Compose?}

Jetpack Compose is Android’s modern UI toolkit for building native user interfaces \textit{declaratively} using Kotlin. It replaces the traditional XML + View system with a Kotlin-first, reactive approach based on composable functions.

Instead of mutating views imperatively, Compose lets you declare how the UI should look based on the current state — and automatically updates the screen when that state changes.

\subsubsection{Declarative UI}
Compose uses a declarative paradigm. UI is emitted by functions marked with \texttt{@Composable}. These functions describe the UI as a function of data.

\begin{lstlisting}[language=Kotlin]
@Composable
fun Greeting(name: String) {
    Text("Hello, $name")
}
\end{lstlisting}

State changes trigger recomposition: only the affected parts of the UI are updated efficiently.

\subsubsection{Why Compose?}
\begin{itemize}
  \item \textbf{No more XML:} All UI is written in Kotlin.
  \item \textbf{Kotlin integration:} Uses lambdas, coroutines, and type safety natively.
  \item \textbf{Reactivity:} UI updates automatically on state changes.
  \item \textbf{Unification:} No need for XML, view IDs, or separate layout files.
  \item \textbf{Tooling:} Live Preview, real-time recomposition, and lint checks in Android Studio.
\end{itemize}

\subsubsection{Under the Hood}
Jetpack Compose compiles \texttt{@Composable} functions into a UI-producing state machine. At runtime:

\begin{itemize}
  \item \textbf{Composer} tracks the UI tree and recomposition logic.
  \item \textbf{Slot Table} stores the structure of emitted UI functions.
  \item \textbf{Applier} applies changes to the actual rendering backend (like View or RenderNode).
  \item \textbf{Recomposer} observes state changes and triggers recomposition as needed.
\end{itemize}

\textbf{Deep Dive:} Compose does not retain views — each recomposition emits a new UI tree. The runtime tracks what changed and updates only the minimal subset, skipping stable nodes thanks to `remember` and smart diffing.

\subsubsection{Comparison with the Old View System}
\begin{table}[h!]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Classic Views} & \textbf{Jetpack Compose} \\
\hline
XML + findViewById() & Kotlin-only UI code \\
State mutation with manual updates & State-driven recomposition \\
Fragmented architecture & Unified Kotlin-first architecture \\
Requires View hierarchy management & Stateless, function-based UI \\
Hard to test or reuse components & Composables are reusable/testable \\
\hline
\end{tabular}
\end{table}

\textbf{Focus Point:} Compose treats UI as a function of immutable state. If the state changes, the UI automatically updates — no more manually updating views or maintaining consistency.


\subsection{Core Concepts}
\label{subsec:compose_core_concepts}

Understanding Jetpack Compose requires mastering its declarative model, how composition works, and how state flows through your UI. This section covers the fundamental building blocks for writing composable, reactive, and efficient UIs.

\subsubsection{@Composable Functions}
A function marked with \texttt{@Composable} is allowed to emit UI. These functions are the primary building blocks of Compose — they do not return a view or a widget, but describe what the UI should look like given a certain input state.

\begin{lstlisting}[language=Kotlin]
@Composable
fun Greeting(name: String) {
    Text("Hello, $name")
}
\end{lstlisting}

Composable functions can call other composable functions and are automatically managed by the Compose runtime.

\textbf{Focus Point:} Compose manages the function calls and tracks their position in the UI tree — this is the basis of composition and recomposition.

\subsubsection{Composition vs Recomposition}
\textbf{Composition} is the initial execution of a composable function — the first time it's added to the UI hierarchy.  
\textbf{Recomposition} is the process by which Compose re-executes composables whose input data (state) has changed.

\begin{itemize}
  \item Composition builds the UI tree.
  \item Recomposition selectively updates only affected composables.
  \item Compose avoids full re-renders: it diffs input changes.
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
@Composable
fun Counter() {
    var count by remember { mutableStateOf(0) }

    Button(onClick = { count++ }) {
        Text("Clicked $count times")
    }
}
\end{lstlisting}

Only the \texttt{Text()} and \texttt{Button()} body are recomposed — not the entire screen.

\subsubsection{State Hoisting and Unidirectional Data Flow}
\textbf{State hoisting} is the practice of moving state out of a composable into a parent, making the composable stateless and reusable.

Instead of managing its own state, a composable takes two parameters:
\begin{itemize}
  \item The \textbf{value} (state).
  \item A \textbf{callback} to modify it (event).
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
@Composable
fun Counter(value: Int, onIncrement: () -> Unit) {
    Button(onClick = onIncrement) {
        Text("Clicked $value times")
    }
}
\end{lstlisting}

State is owned by the parent (e.g., ViewModel), enforcing a one-way data flow.

\textbf{Focus Point:} Hoisted state = better testing, separation of concerns, and reusability.

\subsubsection{remember, mutableStateOf, derivedStateOf, rememberSaveable}

\paragraph{\texttt{remember}}
Caches a value across recompositions during the lifetime of a composable. Used to retain values like state, objects, etc.

\begin{lstlisting}[language=Kotlin]
val counter = remember { mutableStateOf(0) }
\end{lstlisting}

\textbf{Note:} Reset on configuration change or navigation.

\paragraph{\texttt{mutableStateOf}}
Creates a mutable observable value that triggers recomposition when changed.

\begin{lstlisting}[language=Kotlin]
val name = remember { mutableStateOf("Alice") }
\end{lstlisting}

\textbf{Deep Dive:} It implements \texttt{State<T>}, Compose's core observable interface.

\paragraph{\texttt{derivedStateOf}}
Creates a \texttt{State} that derives from other states, and only recomputes when inputs change.

\begin{lstlisting}[language=Kotlin]
val filteredItems = derivedStateOf {
    items.filter { it.isVisible }
}
\end{lstlisting}

Improves recomposition performance when you have expensive logic based on other states.

\paragraph{\texttt{rememberSaveable}}
Like \texttt{remember}, but survives configuration changes (e.g., rotation). Uses the saved instance state under the hood.

\begin{lstlisting}[language=Kotlin]
val username = rememberSaveable { mutableStateOf("") }
\end{lstlisting}

\textbf{Use it for:} Input fields, toggles, scroll positions — anything the user would expect to persist across rotation.

\textbf{Focus Point:} \texttt{remember} keeps value alive only in memory. \texttt{rememberSaveable} persists it using Bundle serialization.


\subsection{Layout System \& Modifiers}
\label{sec:compose_layout}

Jetpack Compose replaces the old ViewGroup/XML hierarchy with a composable layout model. Instead of nesting XML tags, you describe layout using functions like \texttt{Row}, \texttt{Column}, and \texttt{Box}, combined with \texttt{Modifier} chains for configuration.

\subsubsection{Row, Column, Box, LazyColumn}

\textbf{Row}: Arranges elements horizontally in a single line.

\begin{lstlisting}[language=Kotlin]
Row(
    horizontalArrangement = Arrangement.SpaceBetween,
    verticalAlignment = Alignment.CenterVertically
) {
    Text("Left")
    Text("Right")
}
\end{lstlisting}

\textbf{Column}: Arranges elements vertically.

\begin{lstlisting}[language=Kotlin]
Column(
    verticalArrangement = Arrangement.spacedBy(8.dp),
    horizontalAlignment = Alignment.CenterHorizontally
) {
    Text("One")
    Text("Two")
}
\end{lstlisting}

\textbf{Box}: Overlays children on top of each other. Think of it like a frame layout.

\begin{lstlisting}[language=Kotlin]
Box(
    modifier = Modifier.fillMaxSize(),
    contentAlignment = Alignment.Center
) {
    Text("Centered")
}
\end{lstlisting}

\textbf{LazyColumn}: Efficient, scrollable column — similar to RecyclerView.

\begin{lstlisting}[language=Kotlin]
LazyColumn {
    items(100) { index ->
        Text("Item #$index")
    }
}
\end{lstlisting}

\subsubsection{The Modifier Chain: Layout, Gesture, Graphics}

\texttt{Modifier} is a chainable configuration block used to alter layout, appearance, interactivity, and behavior of composables.

Modifiers are applied \textbf{in the order written} — each one wraps the next.

\begin{itemize}
    \item \textbf{Layout}: \texttt{padding}, \texttt{size}, \texttt{offset}, \texttt{fillMaxWidth}.
    \item \textbf{Gesture}: \texttt{clickable}, \texttt{pointerInput}, \texttt{draggable}.
    \item \textbf{Graphics}: \texttt{background}, \texttt{border}, \texttt{alpha}, \texttt{clip}.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
Text(
    "Click Me",
    modifier = Modifier
        .padding(8.dp)
        .background(Color.Red)
        .clickable { /* handle click */ }
)
\end{lstlisting}

\textbf{Focus Point:} Modifiers are applied in order — changing the sequence can affect rendering and behavior.

\subsubsection{Alignment, Spacing, Arrangement}

Jetpack Compose provides fine control over child positioning via alignment and arrangement:

\begin{itemize}
    \item \texttt{horizontalAlignment} and \texttt{verticalArrangement} for \texttt{Column}.
    \item \texttt{verticalAlignment} and \texttt{horizontalArrangement} for \texttt{Row}.
    \item \texttt{contentAlignment} for \texttt{Box}.
\end{itemize}

Common arrangements include:

\begin{itemize}
    \item \texttt{Arrangement.SpaceBetween}
    \item \texttt{Arrangement.Center}
    \item \texttt{Arrangement.spacedBy(8.dp)}
\end{itemize}

\subsubsection{Custom Layouts}

You can build fully custom layouts using the \texttt{Layout} composable.

\begin{lstlisting}[language=Kotlin]
@Composable
fun CustomLayout(
    modifier: Modifier = Modifier,
    content: @Composable () -> Unit
) {
    Layout(
        modifier = modifier,
        content = content
    ) { measurables, constraints ->
        // measure and place children manually
        val placeables = measurables.map { it.measure(constraints) }
        layout(width = constraints.maxWidth, height = constraints.maxHeight) {
            placeables.forEach {
                it.placeRelative(0, 0) // all stacked at top-left
            }
        }
    }
}
\end{lstlisting}

\textbf{Deep Dive:} Use custom layouts for complex arrangements not achievable with built-in composables. Always use \texttt{layout()} to define final size and positions.

\subsection{State in Compose}

State management is a core part of Jetpack Compose. The UI is declarative, meaning it reacts to changes in state. Proper control and propagation of state is essential to building predictable and efficient UIs.

\subsubsection{Composition-local State}

\texttt{CompositionLocal} allows you to pass data implicitly through the composition hierarchy without having to pass it down manually via function parameters.

\begin{lstlisting}[language=Kotlin]
val LocalTheme = compositionLocalOf { LightTheme }

@Composable
fun MyApp() {
    CompositionLocalProvider(LocalTheme provides DarkTheme) {
        MyScreen()
    }
}

@Composable
fun MyScreen() {
    val theme = LocalTheme.current
    // use theme
}
\end{lstlisting}

\textbf{Focus Point:} Use \texttt{CompositionLocal} for values that need to be globally accessible (e.g., theme, localization, app-wide configuration), but avoid overuse as it reduces explicitness and can harm maintainability.

\subsubsection{Integration with ViewModel}

Compose works seamlessly with Jetpack \texttt{ViewModel}. You can observe data using \texttt{collectAsState()} for \texttt{StateFlow}, or \texttt{observeAsState()} for \texttt{LiveData}.

\begin{lstlisting}[language=Kotlin]
@Composable
fun MyScreen(viewModel: MyViewModel = viewModel()) {
    val uiState by viewModel.stateFlow.collectAsState()
    // render UI based on uiState
}
\end{lstlisting}

\textbf{Focus Point:} Prefer using \texttt{StateFlow} or \texttt{LiveData} exposed from the ViewModel and collect it in the UI using \texttt{collectAsState()} to achieve a unidirectional and lifecycle-safe state model.

\subsubsection{LaunchedEffect}

\texttt{LaunchedEffect} runs suspend logic tied to the composition lifecycle. It re-launches when its key changes and is automatically cancelled when the associated composable leaves the composition.

\begin{lstlisting}[language=Kotlin]
@Composable
fun MyScreen(id: String) {
    LaunchedEffect(id) {
        val data = repository.load(id)
        // handle result
    }
}
\end{lstlisting}

\textbf{Focus Point:} Use \texttt{LaunchedEffect} for jobs that must run when the composable appears or when an input key changes. It supports structured concurrency.

\subsubsection{SideEffect}

\texttt{SideEffect} is a synchronous block executed after every successful recomposition. It runs on the main thread and is intended for sending signals to external systems.

\begin{lstlisting}[language=Kotlin]
@Composable
fun LogRecomposition() {
    SideEffect {
        Log.d("Compose", "Recomposed")
    }
}
\end{lstlisting}

\textbf{Focus Point:} \texttt{SideEffect} is only for non-suspending logic such as logging or analytics. Avoid state changes or long-running operations inside it.

\subsubsection{DisposableEffect}

\texttt{DisposableEffect} allows registration and cleanup of resources such as listeners, broadcast receivers, or observers. It is tied to the key provided and cancels automatically when the key changes or the composable is removed.

\begin{lstlisting}[language=Kotlin]
@Composable
fun ObserveLifecycle(owner: LifecycleOwner) {
    DisposableEffect(owner) {
        val observer = LifecycleEventObserver { _, event -> 
            Log.d("Lifecycle", "Event: $event")
        }
        owner.lifecycle.addObserver(observer)
        onDispose {
            owner.lifecycle.removeObserver(observer)
        }
    }
}
\end{lstlisting}

\textbf{Focus Point:} Always call \texttt{onDispose} to unregister callbacks and observers to avoid memory leaks or multiple registrations.

\subsubsection{Lifecycle Integration with Composition}

The lifecycle of a composable is governed by the component hosting the composition (e.g., \texttt{Activity}, \texttt{Fragment}, or \texttt{ComposeView}). When \texttt{setContent} is called, a composition is created and attached to the lifecycle owner. When the lifecycle owner is destroyed, the composition is disposed and all side-effect coroutines are cancelled.

You can access the current \texttt{LifecycleOwner} using \texttt{LocalLifecycleOwner.current}, and attach custom observers.

\begin{lstlisting}[language=Kotlin]
@Composable
fun ObserveEvents() {
    val lifecycleOwner = LocalLifecycleOwner.current
    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event -> 
            // react to event
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
}
\end{lstlisting}

\textbf{Focus Point:} Composables do not expose lifecycle callbacks. Use side-effect APIs like \texttt{DisposableEffect} and \texttt{LaunchedEffect} to handle lifecycle-driven logic.

\subsubsection{Deep Dive: Composition Lifecycle Model}

Each composition instance has a defined lifecycle:

\begin{itemize}
  \item \textbf{Enter composition}: When the composable is first invoked in a frame.
  \item \textbf{Recomposition}: Triggered by state changes that affect the composable.
  \item \textbf{Leave composition}: Happens when the composable is no longer part of the UI tree.
\end{itemize}

Effects like \texttt{LaunchedEffect} and \texttt{DisposableEffect} hook into this lifecycle. Recomposition does not recreate the composable — it updates it in place, reusing the existing slot in the tree.

\textbf{Focus Point:} Don’t rely on constructor/init blocks inside composables. Use effect handlers to react to lifecycle events safely and predictably.

\subsection{Navigation with Compose}

Jetpack Compose provides a dedicated navigation library: \texttt{androidx.navigation:navigation-compose}. It allows managing app navigation in a fully declarative way, integrating tightly with the Compose UI model.

\subsubsection{Navigation Compose Library}

The navigation library offers the core tools needed to build navigation graphs using composable destinations. It eliminates the need for Fragments or XML-based navigation graphs.

\textbf{Key component:} \texttt{NavController} – handles navigation actions and back stack management in a Compose-first way.

\begin{lstlisting}[language=Kotlin]
val navController = rememberNavController()

NavHost(navController, startDestination = "home") {
    composable("home") { HomeScreen(navController) }
    composable("details") { DetailsScreen() }
}
\end{lstlisting}

\textbf{Focus Point:} Always use a single \texttt{NavHost} at the root of your navigation graph. Avoid nesting unless handling nested navigation graphs.

\subsubsection{NavHost, NavController, Composable Destinations}

\begin{itemize}
    \item \texttt{NavHost}: The container that renders composables based on the current destination.
    \item \texttt{NavController}: A state holder and dispatcher that controls the current destination and back stack.
    \item \texttt{composable}: A function used to register a destination in the graph, mapped to a route.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
composable("profile/{userId}") { backStackEntry ->
    val userId = backStackEntry.arguments?.getString("userId")
    ProfileScreen(userId)
}
\end{lstlisting}

\textbf{Deep Dive:} Destinations are defined using string routes. Parameters can be passed as arguments in the route path (e.g., \texttt{"profile/\{userId\}"}).

\subsubsection{Argument Passing, Back Stack, and Deep Links}

\paragraph{Argument Passing}
Arguments can be passed in the route string. You must extract them via \texttt{NavBackStackEntry}.

\begin{lstlisting}[language=Kotlin]
// Navigate to destination with argument
navController.navigate("profile/42")
\end{lstlisting}

\paragraph{Back Stack Management}
\texttt{NavController} manages the back stack automatically. Use \texttt{popBackStack()} to return to the previous destination.

\begin{lstlisting}[language=Kotlin]
navController.popBackStack()
\end{lstlisting}

Use \texttt{popUpTo} with \texttt{inclusive = true} to clear parts of the stack.

\paragraph{Deep Links}
You can define deep links for destinations using the \texttt{deepLinks} parameter.

\begin{lstlisting}[language=Kotlin]
composable(
    route = "settings",
    deepLinks = listOf(navDeepLink { uriPattern = "app://settings" })
) {
    SettingsScreen()
}
\end{lstlisting}

\textbf{Focus Point:} When passing arguments, prefer strongly typed routes with SafeArgs or manually validated routes. Always handle back stack explicitly for critical flows (e.g., authentication, onboarding).

\subsection{UI Toolkit \& Material Design}

Jetpack Compose is built with a deep integration of the Material Design system. It includes full support for \textbf{Material 3} (a.k.a. Material You), with components, theming, and design tokens exposed via the \texttt{MaterialTheme}.

\subsubsection{Material 3 Support}

Compose uses the \texttt{androidx.compose.material3} library to deliver Material 3 components out-of-the-box. This includes support for:

\begin{itemize}
  \item Dynamic color theming (from system wallpaper).
  \item Updated typography and spacing.
  \item Composable versions of Material 3 widgets.
\end{itemize}

You can apply the theme using:

\begin{lstlisting}[language=Kotlin]
MaterialTheme(
    colorScheme = myColorScheme,
    typography = myTypography,
    content = { MyAppContent() }
)
\end{lstlisting}

\textbf{Focus Point:} Material 3 theming works via \texttt{MaterialTheme}. Colors, typography, and shapes are injected through composition.

\subsubsection{Core Widgets}

Compose replaces traditional Views with composables. Some commonly used UI elements include:

\begin{itemize}
  \item \texttt{Text} — for displaying text.
  \item \texttt{Button}, \texttt{OutlinedButton}, \texttt{IconButton}, etc.
  \item \texttt{TextField} — for input, both single and multi-line.
  \item \texttt{Scaffold} — provides Material layout structure (top bar, FAB, snackbar, drawer).
  \item \texttt{Snackbar}, \texttt{Dialog}, \texttt{Card}, \texttt{Icon}.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
Scaffold(
    topBar = { TopAppBar(title = { Text("Home") }) },
    snackbarHost = { SnackbarHost(it) },
    floatingActionButton = {
        FloatingActionButton(onClick = { ... }) {
            Icon(Icons.Default.Add, contentDescription = null)
        }
    }
) {
    MyScreenContent()
}
\end{lstlisting}

\textbf{Deep Dive:} \texttt{Scaffold} manages standard layout regions: content area, snackbar host, FAB, top app bar, etc. It's the Compose equivalent of XML's root layout with toolbars and action buttons.

\subsubsection{Custom Themes with \texttt{MaterialTheme}}

You can customize your entire app's style by overriding the default color scheme, typography, or shapes:

\begin{lstlisting}[language=Kotlin]
val darkColors = darkColorScheme(
    primary = Color(0xFF6200EE),
    onPrimary = Color.White
)

MaterialTheme(
    colorScheme = darkColors,
    typography = Typography,
    shapes = Shapes
) {
    AppContent()
}
\end{lstlisting}

\textbf{Focus Point:} \texttt{MaterialTheme} makes theme data accessible throughout the composition tree. Use \texttt{MaterialTheme.colorScheme.primary} etc. for consistent styling.

\subsection{Interoperability}

Jetpack Compose was designed to interoperate cleanly with the existing View-based UI framework. This enables gradual adoption and allows developers to mix Compose and Views during migration.

\subsubsection{Embedding Compose in View XML — \texttt{ComposeView}}

To insert a Composable inside a traditional View hierarchy, use \texttt{ComposeView} in your layout or code.

\textbf{XML example:}
\begin{lstlisting}[language=XML]
<androidx.compose.ui.platform.ComposeView
    android:id="@+id/compose_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"/>
\end{lstlisting}

\textbf{Kotlin binding:}
\begin{lstlisting}[language=Kotlin]
findViewById<ComposeView>(R.id.compose_view).setContent {
    Text("This is Compose inside XML")
}
\end{lstlisting}

\textbf{Focus Point:} Always set content inside \texttt{onViewCreated()} or \texttt{onCreate()} to avoid leaks and reinitialization issues.

\subsubsection{Embedding Views in Compose — \texttt{AndroidView}}

If you need to reuse an existing custom View or a View-based library inside Compose, use \texttt{AndroidView}.

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
AndroidView(factory = { context ->
    TextView(context).apply {
        text = "Classic TextView"
    }
})
\end{lstlisting}

You can also update the view after creation using the \texttt{update} block.

\begin{lstlisting}[language=Kotlin]
AndroidView(
    factory = { context -> SeekBar(context) },
    update = { seekBar -> seekBar.progress = 50 }
)
\end{lstlisting}

\textbf{Deep Dive:} \texttt{AndroidView} creates and attaches the View to the Compose layout tree. It's still measured and laid out by Compose — do not manipulate it using traditional LayoutParams.

\subsubsection{Migration Strategy}

Jetpack Compose supports incremental migration of screens and components.

\begin{itemize}
  \item Replace individual fragments or activities with Compose screens using \texttt{ComposeView}.
  \item Use \texttt{AndroidView} for custom or third-party widgets not yet available in Compose.
  \item Wrap legacy ViewModels and LiveData using \texttt{collectAsState()} or \texttt{observeAsState()}.
  \item Introduce Compose gradually — feature-by-feature or screen-by-screen.
\end{itemize}

\textbf{Focus Point:} Compose and Views can co-exist in the same app. Migrate gradually — starting from leaf nodes like buttons, dialogs, or toolbars.

\subsection{Performance \& Best Practices}

Compose is optimized for performance, but careless state usage or composition structure can lead to unnecessary recompositions or UI lags. This section focuses on tools and patterns to maintain high-performance UIs.

\subsubsection{Controlling Recomposition}

Recomposition occurs when Compose detects a state change and re-executes a Composable. This is essential but must be scoped properly.

\begin{itemize}
  \item Recomposition is triggered by changes to \texttt{State<T>} or \texttt{MutableState<T>}.
  \item Compose tries to recompose only the smallest possible scope.
  \item Avoid putting expensive logic or mutable state in a top-level composable.
\end{itemize}

\textbf{Focus Point:} Structure your composables so that state changes affect only the smallest UI units.

\subsubsection{Using \texttt{key()} to Scope State}

The \texttt{key()} function helps isolate recomposition when rendering items in lists or dynamic UIs.

\textbf{Example:}
\begin{lstlisting}[language=Kotlin]
LazyColumn {
    items(items = userList, key = { it.id }) { user ->
        key(user.id) {
            UserCard(user)
        }
    }
}
\end{lstlisting}

If the key is stable (e.g., unique ID), Compose will avoid destroying and re-creating components unnecessarily.

\textbf{Focus Point:} Use stable keys when displaying dynamic content like lists or animations to preserve state and reduce recomposition overhead.

\subsubsection{Avoiding Unscoped or Shared State}

Holding mutable state at the wrong level of your UI tree can cause excessive recomposition or bugs.

\begin{itemize}
  \item Don’t define \texttt{remember} or \texttt{mutableStateOf} outside a composable unless it's hoisted correctly.
  \item Avoid sharing mutable state across unrelated composables unless intended.
\end{itemize}

\textbf{Example of a pitfall:}
\begin{lstlisting}[language=Kotlin]
// BAD: Shared mutable state outside composable
val counter = mutableStateOf(0)

@Composable
fun CounterButton() {
    Button(onClick = { counter.value++ }) {
        Text("Count: ${counter.value}")
    }
}
\end{lstlisting}

\textbf{Deep Dive:} Prefer passing state down explicitly via parameters and lifting state up into parent composables or ViewModels (state hoisting).

\subsubsection{Using \texttt{derivedStateOf}}

Use \texttt{derivedStateOf} when a value depends on another state and needs to be recomputed only when that input changes.

\begin{lstlisting}[language=Kotlin]
val items = remember { mutableStateListOf<String>() }

val itemCountText by remember {
    derivedStateOf { "Items: ${items.size}" }
}
\end{lstlisting}

\textbf{Focus Point:} Use \texttt{derivedStateOf} to avoid redundant recomputations when derived data can be cached.

\subsection{Testing Compose}

Jetpack Compose provides a dedicated testing framework that allows for writing expressive and reliable UI tests with full control over Composables, interaction simulation, and assertions.

\subsubsection{ComposeTestRule, \texttt{setContent()}, and Test Environment}

Compose UI tests are powered by \texttt{ComposeTestRule}, which hosts composables inside a test environment.

\begin{lstlisting}[language=Kotlin]
@get:Rule
val composeTestRule = createComposeRule()

@Test
fun myButtonTest() {
    composeTestRule.setContent {
        MyScreen()
    }
    composeTestRule.onNodeWithText("Click me").performClick()
}
\end{lstlisting}

\texttt{setContent()} launches the composable under test in an isolated environment, similar to an Activity.

\textbf{Focus Point:} Always isolate the smallest possible unit of UI in tests — avoid rendering full screens when testing individual components.

\subsubsection{Node Interaction: \texttt{onNode}, \texttt{performClick()}, \texttt{assert*()}}

ComposeTestRule allows querying UI nodes using matchers:

\begin{itemize}
  \item \texttt{onNodeWithText()}, \texttt{onNodeWithTag()}, \texttt{onNode(hasContentDescription(...))}
  \item \texttt{performClick()}, \texttt{performTextInput()}, \texttt{performScrollTo()}
  \item \texttt{assertIsDisplayed()}, \texttt{assertHasClickAction()}, \texttt{assertTextEquals()}
\end{itemize}

\begin{lstlisting}[language=Kotlin]
composeTestRule
    .onNodeWithTag("submit_button")
    .assertIsDisplayed()
    .performClick()
\end{lstlisting}

You can also use \texttt{hasTestTag()}, \texttt{hasText()}, and \texttt{hasClickAction()} for complex matching.

\textbf{Deep Dive:} Use \texttt{Modifier.testTag()} in your composables to expose elements for testing.

\subsubsection{Snapshot Testing Strategies}

Snapshot testing helps detect UI regressions by comparing the actual rendered UI with expected output. While Compose doesn’t provide built-in screenshot testing, libraries like \texttt{Paparazzi} or \texttt{Shot} (for instrumented tests) can be used.

\begin{itemize}
  \item Use snapshot testing to catch visual changes in themes, layout, or font sizes.
  \item Combine with golden images to validate styling and spacing consistency.
\end{itemize}

\textbf{Focus Point:} Use snapshot tests sparingly and focus unit tests on behavior, not visuals — visuals can be fragile due to device density, font scaling, etc.

\subsection{Known Limitations}

While Jetpack Compose offers a modern and flexible approach to UI development, it comes with a few limitations that developers must be aware of — especially in production environments or during migration from the traditional View system.

\subsubsection{Input Handling Quirks}

Certain edge cases involving focus, text input, and the software keyboard are not yet as polished as in the legacy View system.

\begin{itemize}
  \item Focus traversal between text fields may behave unexpectedly in custom layouts.
  \item Manual control over keyboard visibility sometimes requires workarounds.
  \item InputMethodManager integration is still improving.
\end{itemize}

\textbf{Focus Point:} For reliable keyboard handling, prefer using \texttt{LocalSoftwareKeyboardController}, \texttt{FocusRequester}, and lifecycle-aware patterns.

\subsubsection{Performance on Deeply Nested Layouts}

Although Compose is optimized, deeply nested or recomposition-heavy UI trees can introduce performance issues if state or layout is not scoped correctly.

\begin{itemize}
  \item Uncontrolled recompositions can result in dropped frames or lag.
  \item Modifier chains with complex drawing or measurement logic (e.g., many \texttt{graphicsLayer}, \texttt{clip}, \texttt{drawBehind}) can slow down rendering.
\end{itemize}

\textbf{Deep Dive:} Use \texttt{key()}, \texttt{derivedStateOf()}, \texttt{LaunchedEffect()} and \texttt{remember()} to scope recompositions precisely. Use \texttt{Layout Inspector} and \texttt{Recomposition Highlighter} for profiling.

\subsubsection{Ecosystem Still Maturing}

Despite strong support from Google, Compose's ecosystem (libraries, tooling, third-party integrations) is still catching up with the mature and stable View system.

\begin{itemize}
  \item Some Jetpack libraries are not yet Compose-first or Compose-optimized.
  \item UI testing tools, accessibility, and preview tooling continue to evolve.
  \item Libraries like ConstraintLayout, MotionLayout, and VectorDrawable have limited parity or require extra setup.
\end{itemize}

\textbf{Focus Point:} Carefully evaluate Compose for large apps or mission-critical UIs — hybrid strategies or gradual migration are often more stable than full rewrites.


\section{Low-Level Android Architecture}

\subsection{Dalvik and Android Runtime (ART)}

\subsubsection{What Are DVM and ART}

Dalvik and ART are two distinct execution environments for Android applications. Dalvik was the original runtime used until Android 4.4, while ART replaced it as the default in Android 5.0 and above.

Dalvik is a register-based virtual machine executing `.dex` bytecode, optimized for devices with limited memory. ART uses Ahead-of-Time (AOT) compilation, compiling applications into native code at install time.

\subsubsection{Why They Matter}

The runtime determines how application bytecode is executed. It affects memory usage, startup time, performance, and garbage collection. Understanding the transition from DVM to ART explains performance improvements and behavioral differences between Android versions.

\subsubsection{How They Work}

\paragraph{Dalvik}
Dalvik interprets `.dex` bytecode or uses Just-In-Time (JIT) compilation to optimize frequently executed code segments. The interpreter executes instructions one at a time.

\paragraph{ART}
ART performs AOT compilation into ELF executables during app installation, stored in `/data/dalvik-cache` or `/data/app`. This reduces CPU usage at runtime. Android 7+ introduced hybrid JIT + AOT to balance performance and storage cost.

\paragraph{Bytecode Format}
Both runtimes operate on `.dex` (Dalvik Executable) files, which are optimized for minimal memory usage. Multiple `.class` files are merged and converted using the `dx` or `d8` tool.

\paragraph{JIT vs AOT Comparison}\mbox{}\\

\begin{tabular}{|l|l|l|}
\hline
 & \textbf{JIT (Dalvik)} & \textbf{AOT (ART)} \\
\hline
Compilation Time & At runtime & At install time \\
Memory Usage & Higher during execution & Lower at runtime \\
Performance & Slower initially, improves over time & Fast startup, consistent performance \\
Storage Use & Less install-time size & Larger app footprint \\
\hline
\end{tabular}

\subsubsection{Garbage Collection Differences}

Dalvik uses a stop-the-world GC, which introduces frame drops during UI rendering. ART supports concurrent and parallel garbage collection, reducing UI jank and improving responsiveness. GC tuning is possible via flags and differs across Android versions.

\subsubsection{Usage and Developer Considerations}

Although the transition from Dalvik to ART is handled by the system, developers must be aware of:
\begin{itemize}
  \item \textbf{Startup time}: ART improves cold start due to AOT.
  \item \textbf{Debugging behavior}: JIT in ART enables better profiling in development.
  \item \textbf{Dex constraints}: Limits on method counts still apply unless using multidex.
\end{itemize}

\textbf{Focus Point:} Avoid hitting the 64K method limit in `.dex` by enabling multidex or reducing dependencies. ART's AOT may cause longer install times, especially on older devices.

\textbf{Deep Dive:} ART maintains profiling data using the `profileinstaller` API and optimizes apps post-install with background compilation. Developers can inspect app optimization using `adb shell cmd package compile`.

\subsection{Zygote and Process Creation}

Android uses a process called \texttt{zygote} as a template to efficiently start new app processes. Zygote is a pre-initialized system process that loads and initializes the Android runtime, core libraries, and resources once at boot. Every new app process is created by forking from the \texttt{zygote} process.

\subsubsection{What is Zygote}

\texttt{Zygote} is a long-running system process started during device boot. It preloads:
\begin{itemize}
  \item Android framework classes (e.g., \texttt{Activity}, \texttt{View}, \texttt{Context}).
  \item Core libraries (e.g., \texttt{java.util}, \texttt{android.util}).
  \item Resources like fonts and drawables.
\end{itemize}

Forking from a preloaded process allows the OS to use **Copy-On-Write (COW)** memory sharing, reducing startup time and memory consumption.

\subsubsection{Why It Exists}

Creating a new Linux process and loading the entire Android framework each time would be slow and memory-intensive. Zygote solves this by:
\begin{itemize}
  \item Avoiding repeated class loading and initialization.
  \item Sharing memory pages between app processes until modified (COW).
  \item Enabling faster app launch via process forking.
\end{itemize}

\textbf{Focus Point:} Zygote improves startup time and memory usage through Copy-On-Write memory after forking.

\subsubsection{How It Works Under the Hood}

\begin{enumerate}
  \item At boot, \texttt{init.rc} starts the \texttt{zygote} process.
  \item Zygote loads the ART runtime and preloads framework classes/resources.
  \item When an app is launched, the ActivityManagerService (AMS) sends a command to Zygote via a local socket.
  \item Zygote forks itself, creating a child process with identical memory.
  \item The child process initializes the \texttt{ActivityThread} and enters the main application loop.
\end{enumerate}

This model enables process isolation with minimal startup overhead.

\begin{lstlisting}[language=Kotlin]
// Conceptual steps (not real code)
val zygoteSocket = LocalSocket("zygote")
zygoteSocket.send("fork new process")
val child = zygote.fork()
child.runMainActivity()
\end{lstlisting}

\textbf{Deep Dive:} Zygote uses UNIX domain sockets to receive fork requests and supports multiple zygotes (e.g., zygote32, zygote64) based on app ABI. Since Android 10, secondary zygotes exist to optimize processes like webview rendering.

\textbf{Focus Point:} Each app runs in its own process space with its own UID, but memory for shared classes is inherited from Zygote, saving both time and RAM.

\subsection{Android Application Lifecycle: Process, Thread, Looper}

Each Android application runs in its own Linux process, with its own instance of the Android Runtime (ART), heap, and security sandbox. Understanding the structure of this process and how execution flows through threads and the event loop is essential for correct lifecycle handling and responsiveness.

\subsubsection{Main Thread and Looper}

At process startup, Android invokes the \texttt{ActivityThread} class, which is the entry point for all components (Activities, Services, etc.).

This thread, also known as the \textbf{main thread} or \textbf{UI thread}, is responsible for:
\begin{itemize}
  \item Initializing the app.
  \item Running the main event loop via a \texttt{Looper}.
  \item Handling lifecycle callbacks and UI events.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
// Simplified view of the main thread setup
fun main() {
    Looper.prepareMainLooper()  // Creates a Looper for the thread
    val handler = Handler(Looper.getMainLooper())
    Looper.loop()               // Starts the infinite message loop
}
\end{lstlisting}

\texttt{Looper} maintains a queue of \texttt{Message} objects (in \texttt{MessageQueue}) and processes them one-by-one using \texttt{Handler}. This is how asynchronous events like input or lifecycle callbacks are delivered.

\textbf{Focus Point:} Never block the main thread — it must remain responsive. Use background threads for I/O and computation.

\subsubsection{Component Lifecycle and Process Lifetime}

Each component has its own lifecycle, but they all live within the app’s single process. The system may kill this process at any time to reclaim resources. Key principles:
\begin{itemize}
  \item Process is started on first component launch.
  \item Process stays alive as long as there is at least one foreground or cached component.
  \item Once all components are removed and memory is low, the system may terminate the process.
\end{itemize}

Component lifecycles are managed through callbacks like \texttt{onCreate()}, \texttt{onStart()}, etc., but these callbacks are ultimately dispatched by the main thread.

\textbf{Focus Point:} Android does not notify when the process is about to be killed. Always persist critical state in \texttt{onSaveInstanceState()} or ViewModel.

\subsubsection{Background Threads and Thread Affinity}

Only the main thread can update the UI. Use background threads for:
\begin{itemize}
  \item Network calls (e.g., Retrofit).
  \item Disk access (e.g., Room).
  \item Heavy computations.
\end{itemize}

Threading tools:
\begin{itemize}
  \item \texttt{Thread}, \texttt{ExecutorService}
  \item \texttt{HandlerThread}
  \item \texttt{CoroutineScope(Dispatchers.IO)}
\end{itemize}

\begin{lstlisting}[language=Kotlin]
CoroutineScope(Dispatchers.IO).launch {
    val data = repository.loadData()
    withContext(Dispatchers.Main) {
        updateUI(data)
    }
}
\end{lstlisting}

\textbf{Deep Dive:} Internally, the \texttt{ActivityThread} communicates with the system server using Binder IPC. It receives messages like "launch activity" or "stop service" and posts them to the main thread's Looper.

\textbf{Focus Point:} Always assume lifecycle callbacks run on the main thread unless explicitly documented otherwise.

\subsection{Threading Model: Looper, Handler and MessageQueue}

Android’s threading model is based on a message-driven architecture where a thread can be equipped with a \texttt{Looper} to process asynchronous events through a \texttt{MessageQueue}. This architecture underpins the UI thread (main thread) and any background thread configured for message handling.

This section expands on the Looper-based threading mechanism already introduced in the application lifecycle, focusing on how to manually build asynchronous message loops on custom threads.

\subsubsection{Looper}

\texttt{Looper} is a class that runs a message loop for a thread. It retrieves \texttt{Message} objects from a \texttt{MessageQueue} and dispatches them to the appropriate \texttt{Handler}.

Only one \texttt{Looper} can be associated with a thread.

\begin{lstlisting}[language=Kotlin]
// Setting up a Looper on a custom thread
val thread = Thread {
    Looper.prepare()
    val handler = Handler(Looper.myLooper()!!)
    Looper.loop()
}
thread.start()
\end{lstlisting}

The main thread automatically has a Looper (\texttt{Looper.getMainLooper()}).

\subsubsection{Handler}

A \texttt{Handler} is responsible for:
\begin{itemize}
  \item Sending \texttt{Message} or \texttt{Runnable} to a thread’s \texttt{MessageQueue}.
  \item Receiving and handling messages in the thread’s context.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
val handler = Handler(Looper.getMainLooper())
handler.post {
    // Executes on the main thread
}
\end{lstlisting}

Each Handler is bound to a specific Looper and thread. When a Handler posts a message, it is enqueued and later dispatched to \texttt{handleMessage()}.

\subsubsection{MessageQueue}

\texttt{MessageQueue} is a FIFO queue of \texttt{Message} objects processed by the \texttt{Looper}. It supports:
\begin{itemize}
  \item Scheduling with delay.
  \item Removing pending messages.
  \item IdleHandler for queue-idle hooks.
\end{itemize}

Messages are removed from the queue and delivered in the order of their scheduled time.

\subsubsection{Main Thread Example}

\begin{lstlisting}[language=Kotlin]
val handler = Handler(Looper.getMainLooper())
handler.postDelayed({
    println("Executed on main thread")
}, 1000)
\end{lstlisting}

This posts a task to be executed after 1 second on the main thread’s Looper.

\textbf{Focus Point:} \texttt{Handler}, \texttt{Looper}, and \texttt{MessageQueue} form the foundation of Android's single-threaded event loop model. UI components and lifecycle methods are always called on the main thread and must never block it.

\textbf{Deep Dive:} Internally, \texttt{Looper.loop()} blocks the thread, pulling messages using a native polling mechanism (\texttt{epoll}), which wakes up when a new message is available or a timeout occurs. This model allows high throughput with low overhead.

\subsection{App Launch Modes: Cold, Warm and Hot Start}

Android applications can be launched in different ways depending on their current process state and memory residency. These are classified as Cold Start, Warm Start, and Hot Start. Understanding the distinctions helps optimize startup time and user experience.

\subsubsection{Cold Start}

Occurs when the app process is not in memory. The system must:

\begin{itemize}
  \item Start a new Linux process via \texttt{Zygote}.
  \item Instantiate the \texttt{Application} class.
  \item Instantiate and call \texttt{onCreate()} on the \texttt{Activity}.
  \item Inflate views and render UI.
\end{itemize}

This is the most expensive startup mode in terms of time and CPU/memory usage.

\textbf{Focus Point:} Cold start includes both process and UI initialization. Minimize work in \texttt{Application.onCreate()} and defer heavy operations.

\subsubsection{Warm Start}

Occurs when the process is still alive, but the activity was destroyed (e.g., due to memory pressure). Android performs:

\begin{itemize}
  \item New \texttt{Activity} instance creation.
  \item Call to \texttt{onCreate()}, \texttt{onStart()}, \texttt{onResume()}.
  \item UI reconstruction and rendering.
\end{itemize}

No need to re-initialize the entire process or the \texttt{Application} class.

\textbf{Focus Point:} Use \texttt{onSaveInstanceState()} to retain critical UI state during warm restarts.

\subsubsection{Hot Start}

Occurs when the process and activity are both in memory (e.g., user pressed Home and then re-opened the app). Only the following steps are needed:

\begin{itemize}
  \item \texttt{onRestart()}, \texttt{onStart()}, \texttt{onResume()} on the Activity.
  \item No new UI inflation or memory reallocation.
\end{itemize}

This is the fastest startup path.

\textbf{Focus Point:} Hot start resumes the existing activity. Minimize work in lifecycle methods to ensure a smooth transition.

\subsubsection{Comparison Summary}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Mode} & \textbf{Process Exists} & \textbf{Activity Exists} & \textbf{Startup Cost} \\
\hline
Cold Start & NO & NO & High \\
Warm Start & YES & NO & Medium \\
Hot Start & YES & YES & Low \\

\hline
\end{tabular}
\end{table}

\subsection{Binder IPC and System Services}

Android uses the Binder IPC (Inter-Process Communication) mechanism to enable secure and efficient communication between processes. This mechanism is fundamental for communication between apps and system services (e.g., \texttt{ActivityManager}, \texttt{WindowManager}).

\subsubsection{What Is Binder}

Binder is a kernel-level IPC driver that allows processes to call methods on remote objects as if they were local. It implements the Remote Procedure Call (RPC) pattern and is optimized for low-overhead communication.

Each process in Android has a Binder thread pool managed by the runtime. A typical IPC flow involves marshalling data into a \texttt{Parcel}, sending it through Binder, and unmarshalling it on the other side.

\textbf{Focus Point:} Binder is asynchronous by default and works on top of file descriptors and shared memory to reduce context switching overhead.

\subsubsection{AIDL and Interface Definition}

Android Interface Definition Language (AIDL) allows the definition of Binder interfaces. The AIDL compiler generates proxy and stub code for client-server interaction.

\begin{lstlisting}[language=Kotlin]
// IRemoteService.aidl
interface IRemoteService {
    String getData();
}
\end{lstlisting}

This generates:
\begin{itemize}
  \item A stub: runs on the server side.
  \item A proxy: runs on the client side.
\end{itemize}

\textbf{Focus Point:} Use AIDL only when communicating across processes. For in-process abstraction, prefer direct interface or shared ViewModel.

\subsubsection{System Services}

System services are long-lived singleton components (running in system\_server) that expose APIs via Binder. Examples include:

\begin{itemize}
  \item \texttt{ActivityManager}
  \item \texttt{WindowManager}
  \item \texttt{LocationManager}
  \item \texttt{NotificationManager}
\end{itemize}

These are accessed via \texttt{Context.getSystemService()}:

\begin{lstlisting}[language=Kotlin]
val locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager
\end{lstlisting}

Under the hood, this binds to a remote service in the system process via a Binder proxy.

\subsubsection{Binder Thread Pool}

Each app process includes a Binder thread pool (by default ~4 threads). These threads are used to handle incoming IPC calls.

\textbf{Deep Dive:} If a service exposes synchronous IPC methods and takes too long to respond, it can block the Binder thread and cause ANRs. Always avoid heavy work inside Binder methods.

\textbf{Focus Point:} All communication with system services goes through Binder. Misusing synchronous IPC or leaking Binder interfaces can lead to memory leaks or blocked threads.

\subsection{Garbage Collection in Android Runtime}

The Android Runtime (ART) uses automatic memory management with Garbage Collection (GC) to reclaim memory allocated to objects no longer in use. Understanding how GC works is critical for performance tuning and avoiding UI jank or memory leaks.

\subsubsection{GC in ART}

ART employs a generational, concurrent, and mostly non-blocking garbage collector. The heap is split into:

\begin{itemize}
  \item \textbf{Young Generation (nursery)} — where short-lived objects are allocated.
  \item \textbf{Old Generation (tenured)} — where long-lived objects are promoted after surviving several GC cycles.
\end{itemize}

GC runs in two main phases:
\begin{itemize}
  \item \textbf{Minor GC} — targets the young generation, fast and frequent.
  \item \textbf{Full GC (Major)} — collects across the whole heap, slower and more expensive.
\end{itemize}

\textbf{Focus Point:} Avoid excessive allocations in hot code paths like UI rendering or scrolling — it increases GC pressure and leads to frame drops.

\subsubsection{GC Types in ART}

Depending on the Android version and runtime configuration, ART uses:

\begin{itemize}
  \item \texttt{CMS (Concurrent Mark-Sweep)} — legacy collector.
  \item \texttt{GSS (Garbage-First Soft-References)} — incremental and compacting.
  \item \texttt{Generational CMS} — generational variant of CMS for Android 6+.
\end{itemize}

Modern ART (Android 8+) supports concurrent copying collectors that perform:
\begin{itemize}
  \item Concurrent mark
  \item Concurrent sweep
  \item Copying of reachable objects to compact the heap
\end{itemize}

\textbf{Deep Dive:} ART integrates GC with the app's thread model. The GC pauses the world briefly to mark roots and uses barriers to handle concurrent mutations.

\subsubsection{GC Triggers}

GC is triggered when:
\begin{itemize}
  \item Allocation fails due to lack of free memory.
  \item Explicit call to \texttt{System.gc()} (strongly discouraged).
  \item Memory pressure events from the OS.
\end{itemize}

You can monitor GC via logcat:
\begin{verbatim}
I/art: Explicit concurrent mark sweep GC freed 320K, 10% free ...
\end{verbatim}

\textbf{Focus Point:} GC may happen on the main thread if background GC cannot keep up — always profile memory usage with tools like Android Studio Profiler.

\subsubsection{Best Practices}

\begin{itemize}
  \item Reuse objects in adapters or scrolling views.
  \item Avoid memory leaks via static references to Context.
  \item Prefer \texttt{WeakReference} or Jetpack \texttt{ViewModel} for caching.
  \item Monitor allocations with \texttt{-Xlog:gc} or memory profiler.
\end{itemize}

\textbf{Focus Point:} The GC is efficient, but not free. Reduce memory churn and object lifetime unpredictability in critical performance paths (e.g., rendering, animations).

\subsection{Android and the Linux Kernel}

Android runs on top of the Linux kernel but with several Android-specific modifications to support mobile hardware, security, and power efficiency. The kernel provides the foundation for process scheduling, memory management, file systems, device drivers, and IPC.

\subsubsection{Role of the Kernel}

The Linux kernel in Android is responsible for:

\begin{itemize}
  \item \textbf{Process and thread scheduling} — using the Completely Fair Scheduler (CFS).
  \item \textbf{Memory management} — with support for virtual memory, mmap, paging, and low memory killer.
  \item \textbf{Drivers} — to interface with hardware components (e.g., GPU, audio, sensors).
  \item \textbf{Power management} — with features like wakelocks and CPU frequency scaling.
  \item \textbf{Security enforcement} — via SELinux and seccomp filters.
\end{itemize}

\textbf{Focus Point:} Android modifies and extends the kernel for mobile constraints. Not all mainline Linux features are available or used the same way.

\subsubsection{Android-Specific Kernel Features}

\begin{itemize}
  \item \textbf{Binder} — low-overhead IPC mechanism for communication between system services and apps.
  \item \textbf{Wakelocks} — prevent the CPU from sleeping during critical operations.
  \item \textbf{Low Memory Killer (deprecated)} — user-space processes are killed under memory pressure. Now replaced by \texttt{LMKD} and PSI-based reclamation.
  \item \textbf{Ashmem} — anonymous shared memory for efficient memory sharing (now replaced by \texttt{memfd} in newer versions).
  \item \textbf{Ion} — memory allocator for multimedia buffers.
\end{itemize}

\subsubsection{Kernel Drivers and HAL}

Most hardware communication in Android goes through:

\begin{itemize}
  \item \textbf{Kernel Drivers} — compiled C modules that interact with hardware (e.g., touchscreen, camera).
  \item \textbf{Hardware Abstraction Layer (HAL)} — sits between drivers and Android Framework.
\end{itemize}

\textbf{Deep Dive:} Android’s HAL defines a stable API for each hardware class (e.g., \texttt{audio}, \texttt{camera}, \texttt{sensors}) that vendors must implement. With Treble (Android 8+), HALs can be updated independently from the Android framework.

\subsubsection{Security}

The Linux kernel enforces security using:

\begin{itemize}
  \item \textbf{Namespaces and cgroups} — to isolate apps and manage resources.
  \item \textbf{SELinux} — mandatory access control enforced by the kernel. All access requests must comply with SELinux policies.
  \item \textbf{Verified boot and dm-verity} — ensures that the system partition has not been tampered with.
\end{itemize}

\textbf{Focus Point:} The kernel enforces process isolation, memory protection, and I/O security — all essential to Android’s sandboxing model.


\section{Build System and SDK Tools}

\subsection{Gradle in Android}

Gradle is the default build system for Android. It manages compilation, packaging, dependency resolution, and custom build logic via plugins and configuration scripts.

\subsubsection{What It Is}

Gradle is a task-based automation system. It executes build steps as directed acyclic tasks. Android projects use the Android Gradle Plugin (AGP), which integrates Gradle with Android-specific tasks like APK/AAB packaging and manifest merging.

\subsubsection{Why It Exists}

Before Gradle, Android used Ant and Eclipse-based builders, which lacked flexibility and modularity. Gradle allows:

\begin{itemize}
  \item Declarative and scriptable build logic.
  \item Fine-grained control of variants (flavors + build types).
  \item Modular builds with reusable modules.
  \item Tooling integration with Android Studio.
\end{itemize}

\subsubsection{How It Works}

Gradle interprets the project's \texttt{build.gradle.kts} (Kotlin DSL) or \texttt{build.gradle} (Groovy DSL) scripts and creates a task graph. Tasks are linked to compile code, merge resources, apply ProGuard, sign, and package.

\textbf{Key files:}
\begin{itemize}
  \item \texttt{settings.gradle[.kts]} — defines which modules are included.
  \item \texttt{build.gradle[.kts]} (project-level) — declares buildscript dependencies, repositories, and plugins.
  \item \texttt{build.gradle[.kts]} (module-level) — defines android block, dependencies, and custom tasks.
\end{itemize}

\subsubsection{Basic Android Build Script (Kotlin DSL)}

\begin{lstlisting}[language=Kotlin]
plugins {
    id("com.android.application")
    kotlin("android")
}

android {
    compileSdk = 34

    defaultConfig {
        applicationId = "com.example.app"
        minSdk = 24
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"
    }

    buildTypes {
        release {
            isMinifyEnabled = true
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"))
        }
    }
}

dependencies {
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
}
\end{lstlisting}

\subsubsection{Build Lifecycle}

Gradle phases:

\begin{itemize}
  \item \textbf{Initialization} — Determines which projects to build.
  \item \textbf{Configuration} — Configures all tasks for the selected projects.
  \item \textbf{Execution} — Executes requested tasks and their dependencies.
\end{itemize}

\textbf{Focus Point:} Even if only one task is requested, Gradle configures all tasks across all subprojects unless configuration is avoided via lazy APIs (e.g., \texttt{register()} vs \texttt{create()}).

\subsubsection{Dependency Resolution}

Gradle supports:

\begin{itemize}
  \item Local \texttt{libs} directory.
  \item Maven repositories (e.g., Maven Central, Google).
  \item Transitive resolution.
  \item Conflict resolution via \texttt{resolutionStrategy}.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
configurations.all {
    resolutionStrategy {
        force("org.jetbrains.kotlin:kotlin-stdlib:1.9.0")
    }
}
\end{lstlisting}

\textbf{Deep Dive:} Gradle uses a dependency graph and a component metadata model. It selects the highest version of any library by default unless explicitly overridden.

\textbf{Focus Point:} Avoid version mismatches between transitive dependencies (e.g., conflicting AppCompat versions) by explicitly aligning versions in the build script.

\subsection{Gradle Tasks}

Gradle tasks are discrete units of work in the build lifecycle, defined in DAG form. They can compile, test, package, lint, or deploy your app. Custom tasks can orchestrate additional steps.

\subsubsection{What They Are and How They Work}

Each task has:
\begin{itemize}
  \item A unique name and type (e.g., \texttt{Copy}, \texttt{Jar}).
  \item Inputs and outputs to support incremental and cached builds.
  \item A body executed in the Execution phase.
\end{itemize}

Tasks are wired via the DAG—Gradle resolves execution order based on dependencies

\subsubsection{Common Android Tasks}

\begin{itemize}
  \item \texttt{assembleDebug}, \texttt{assembleRelease}: compile and package APKs.
  \item \texttt{build}: alias for assemble + test.
  \item \texttt{clean}: deletes the \texttt{build/} folder.
  \item \texttt{lint}, \texttt{test}, \texttt{connectedCheck}: static analysis and tests 
  \item \texttt{bundle}: assembles Android App Bundle (AAB).
\end{itemize}

\subsubsection{How to List and Run Tasks}

From terminal:
\begin{lstlisting}
./gradlew tasks          // shows task groups
./gradlew :app:assembleDebug
\end{lstlisting}

Tasks can be executed individually or grouped, optionally with JVM args:
\begin{lstlisting}
./gradlew build -PenableFeatureX --info
\end{lstlisting}

IDE support in Android Studio shows tasks in the Gradle tool window.

\subsubsection{Custom Task Example}

Define a custom task that processes APK after build:

\begin{lstlisting}[language=Kotlin]
tasks.register<Copy>("addTimestamp") {
    dependsOn("assembleRelease")
    from("$buildDir/outputs/apk/release")
    into("$buildDir/outputs/stamped")
    doFirst { println("Stamping APK") }
    rename { name -> name.replace(".apk", "-${System.currentTimeMillis()}.apk") }
}
\end{lstlisting}

This task:
\begin{itemize}
  \item Runs after \texttt{assembleRelease}.
  \item Applies input/output checks—won’t run if no changes.
  \item Uses incremental build mechanism.
\end{itemize}

\subsubsection{Task Types and Caching}

Built-in types include \texttt{Copy}, \texttt{Zip}, \texttt{Delete}, \texttt{Jar}, \texttt{Test}, \texttt{JacocoReport}.

Tasks configured with correct inputs/outputs can be up-to-date or cached between builds.

\textbf{Deep Dive:} Gradle analyzes task inputs and outputs during Configuration to construct a task graph. In Execution, tasks run respecting dependencies, and caching avoids redundant work.

\textbf{Focus Point:} Use \texttt{tasks.register()} for lazy task creation. Define precise inputs/outputs to leverage incremental builds and caching.

\textbf{Focus Point:} Prefer running specific tasks (e.g., \texttt{assembleDebug}) instead of \texttt{build} to avoid unnecessary work across modules.

\subsection{Android SDK and Build Tools Overview}

The Android SDK and associated Build Tools form the foundation for compiling, packaging, and deploying Android applications. These components are versioned independently and maintained via the Android SDK Manager.

\subsubsection{What the Android SDK Contains}

The SDK includes:

\begin{itemize}
  \item \textbf{Platform APIs}: Java and Kotlin interfaces for Android OS functionality.
  \item \textbf{Platform tools}: \texttt{adb}, \texttt{fastboot}, \texttt{systrace}, etc.
  \item \textbf{Build tools}: Compilers and utilities used during build (\texttt{aapt2}, \texttt{d8}, \texttt{zipalign}, \texttt{lint}).
  \item \textbf{System images}: Emulator binaries for each API level.
  \item \textbf{NDK/LLDB}: Native development toolchains for C/C++.
  \item \textbf{SDK Tools}: Additional tools like \texttt{avdmanager}, \texttt{sdkmanager}, etc.
\end{itemize}

\subsubsection{Build Tools}

Build Tools are a set of command-line utilities used internally by Gradle to package and optimize the APK.

\begin{itemize}
  \item \texttt{aapt2}: Compiles and links resources (\texttt{res/}, \texttt{AndroidManifest.xml}) into a binary form.
  \item \texttt{d8}/\texttt{r8}: Dex compiler and shrinker/optimizer.
  \item \texttt{zipalign}: Ensures uncompressed alignment of resources for runtime performance.
  \item \texttt{apksigner}: Signs APKs with cryptographic keys.
\end{itemize}

\textbf{Focus Point:} You can specify the version of build tools via \texttt{build.gradle} (e.g., \texttt{buildToolsVersion = "34.0.0"}), but newer AGP versions often auto-select the required tools.

\subsubsection{AGP (Android Gradle Plugin) Integration}

The AGP bridges Gradle with the Android SDK. It manages:

\begin{itemize}
  \item Code and resource merging.
  \item Dependency resolution for SDK/NDK.
  \item Variant generation (debug/release).
  \item Integration with Lint, instrumentation tests, and build caching.
\end{itemize}

\textbf{Deep Dive:}

\begin{itemize}
  \item \textbf{Compilation}: Java/Kotlin → class files → dex via \texttt{d8}.
  \item \textbf{Resource Packaging}: XML, PNG, etc. → \texttt{aapt2} → \texttt{.arsc}, \texttt{R.class}.
  \item \textbf{APK Generation}: Dex + resources + manifest → \texttt{zipalign} → \texttt{apksigner}.
\end{itemize}

\begin{lstlisting}[language=bash]
// Example command using aapt2 manually
aapt2 compile res/layout/main.xml -o out/
aapt2 link -I $ANDROID_HOME/platforms/android-34/android.jar \
           --manifest AndroidManifest.xml \
           -o output.apk out/*.flat
\end{lstlisting}

\textbf{Focus Point:} Manual use of Build Tools is useful for debugging or low-level build customization, but in most cases AGP and Gradle abstract these layers.

\subsection{Build Variants and Product Flavors}

Android build variants represent different versions of the app generated from the same codebase, each with its own configurations, resources, and dependencies. The Gradle plugin combines \texttt{buildTypes} and \texttt{productFlavors} to generate these variants.

\subsubsection{Build Types}

\texttt{buildTypes} define how the app should be built and packaged. The default types are:

\begin{itemize}
  \item \texttt{debug}: Enables debugging features, disables optimizations, signs with debug key.
  \item \texttt{release}: Enables code shrinking, optimization, and obfuscation. Requires manual signing config.
\end{itemize}

\begin{lstlisting}[language=Kotlin]
android {
    buildTypes {
        debug {
            applicationIdSuffix ".debug"
            debuggable true
        }
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile("proguard-android-optimize.txt"),
                          "proguard-rules.pro"
        }
    }
}
\end{lstlisting}

\textbf{Focus Point:} Never release a build with \texttt{debuggable = true} — it introduces serious security risks.

\subsubsection{Product Flavors}

\texttt{productFlavors} define alternative versions of the app (e.g., free vs. paid, staging vs. prod). Each flavor can override:

\begin{itemize}
  \item \texttt{applicationId}
  \item \texttt{versionCode} and \texttt{versionName}
  \item Source sets: \texttt{src/free/}, \texttt{src/pro/}, etc.
  \item Dependencies
\end{itemize}

\begin{lstlisting}[language=Kotlin]
android {
    flavorDimensions += "tier"
    productFlavors {
        free {
            dimension "tier"
            applicationIdSuffix ".free"
        }
        pro {
            dimension "tier"
            applicationIdSuffix ".pro"
        }
    }
}
\end{lstlisting}

\textbf{Focus Point:} Use dimensions to support multiple axes of variation (e.g., environment + tier).

\subsubsection{Build Variant Matrix}

The final build variants are the Cartesian product of \texttt{buildTypes} × \texttt{productFlavors}. Example:

\begin{itemize}
  \item \texttt{freeDebug}, \texttt{freeRelease}
  \item \texttt{proDebug}, \texttt{proRelease}
\end{itemize}

\subsubsection{Variant-Specific Code and Resources}

Use dedicated directories or suffixes to override code and resources:

\begin{itemize}
  \item \texttt{src/free/java/...}, \texttt{src/pro/res/...}
  \item \texttt{src/debug/AndroidManifest.xml}
  \item \texttt{src/proRelease/...}
\end{itemize}

\textbf{Deep Dive:} Gradle merges source sets and resolves conflicts based on specificity: \texttt{variant-specific} → \texttt{flavor-specific} → \texttt{build-type-specific} → \texttt{main/}.

\subsection{Gradle Build Phases and Plugin System}

Gradle organizes the build into distinct phases and relies on a plugin-based architecture to extend functionality. The Android Gradle Plugin (AGP) transforms raw source code into APKs or AABs through a customizable task graph.

\subsubsection{Build Lifecycle Phases}

Gradle executes builds in three main phases:

\begin{itemize}
  \item \textbf{Initialization}: Determines which projects are part of the build and configures their settings.
  \item \textbf{Configuration}: Parses the \texttt{build.gradle} files and creates the task graph.
  \item \textbf{Execution}: Runs the tasks selected for the requested build (e.g., \texttt{assembleDebug}).
\end{itemize}

\textbf{Focus Point:} Every task is only configured if it’s part of the final graph. Use \texttt{gradle.taskGraph.whenReady} to inspect active tasks.

\subsubsection{Android Gradle Plugin (AGP)}

AGP is a Gradle plugin that adds Android-specific build logic. It automatically creates tasks for:

\begin{itemize}
  \item Java/Kotlin compilation
  \item Manifest merging
  \item Resource merging and shrinking
  \item Code shrinking (R8)
  \item Packaging (APK/AAB)
  \item Signing and zip-align
\end{itemize}

It injects hooks into the Gradle build lifecycle using the \texttt{com.android.application} or \texttt{com.android.library} plugin.

\begin{lstlisting}[language=Kotlin]
plugins {
    id("com.android.application")
    id("kotlin-android")
}
\end{lstlisting}

\textbf{Focus Point:} AGP version must match the Android Gradle Plugin version compatible with your Gradle version — check official compatibility tables.

\subsubsection{Gradle Tasks and Dependency Graph}

Gradle defines each build step as a \texttt{Task}. Tasks declare:

\begin{itemize}
  \item Inputs: files, values
  \item Outputs: files
  \item Dependencies on other tasks
\end{itemize}

Gradle only re-executes tasks if inputs or outputs have changed (up-to-date checks).

\textbf{Example:}

\begin{lstlisting}[language=Kotlin]
tasks.register("printVersion") {
    doLast {
        println("Version: ${project.version}")
    }
}
\end{lstlisting}

Use \texttt{./gradlew tasks} to inspect available tasks.

\subsubsection{Custom Plugins}

Plugins encapsulate reusable logic and can be:

\begin{itemize}
  \item \textbf{Script plugins}: written directly in \texttt{build.gradle.kts}
  \item \textbf{Binary plugins}: compiled and applied via \texttt{id()} in \texttt{plugins} block
\end{itemize}

\textbf{Example Plugin:}
\begin{lstlisting}[language=Kotlin]
// buildSrc/src/main/kotlin/MyPlugin.kt
class MyPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        project.tasks.register("hello") {
            doLast { println("Hello from plugin") }
        }
    }
}
\end{lstlisting}

\textbf{Focus Point:} Use plugins to reduce duplication in multi-module projects — especially for common configuration logic.

\textbf{Deep Dive: D8 vs R8}

\begin{itemize}
  \item \textbf{D8} is the default \textit{dexer} that converts Java/Kotlin bytecode (\texttt{.class}) into \texttt{.dex} files used on Android devices. It performs basic optimizations and desugaring but does not shrink or obfuscate code.
  
  \item \textbf{R8} is a full replacement for both ProGuard and D8. It performs:
  \begin{itemize}
    \item \textbf{Shrinking} — removes unused classes, methods, and fields.
    \item \textbf{Obfuscation} — renames symbols to reduce APK size and increase security.
    \item \textbf{Optimization} — inlines methods, removes dead code, propagates constants.
    \item \textbf{Dexing} — final conversion to \texttt{.dex} format.
  \end{itemize}

  \item R8 is automatically enabled in \texttt{release} builds when \texttt{minifyEnabled} is \texttt{true}:
\begin{lstlisting}[language=Groovy]
android {
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro"
        }
    }
}
\end{lstlisting}

  \item \textbf{D8} is used for \texttt{debug} builds and when \texttt{minifyEnabled} is \texttt{false}. It is faster and preserves readable names for easier debugging.

\end{itemize}

\textbf{Focus Point:} R8 is an aggressive optimizer. Use ProGuard rules carefully to avoid removing code needed at runtime (e.g., via reflection). Use \texttt{-keep} directives for entry points, libraries, and classes accessed dynamically.

\subsection{APK Structure, Alignment and Signing Process}

An APK (Android Package) is the final binary package distributed and installed on Android devices. It is essentially a signed ZIP archive with a defined internal structure and specific alignment and signing requirements.

\subsubsection{APK Structure}

An APK contains compiled code, resources, native libraries, and metadata:

\begin{itemize}
  \item \texttt{classes.dex} — Dalvik bytecode (may be multiple files: \texttt{classes2.dex}, etc.).
  \item \texttt{res/} — compiled resources (layouts, drawables, etc.).
  \item \texttt{assets/} — raw, uncompiled assets bundled into the APK.
  \item \texttt{lib/} — compiled native libraries, separated by ABI (e.g., \texttt{armeabi-v7a}, \texttt{arm64-v8a}).
  \item \texttt{META-INF/} — contains signing certificates, signature files, and manifest.
  \item \texttt{AndroidManifest.xml} — compiled XML declaring app metadata and components.
  \item \texttt{resources.arsc} — compiled binary representation of resources and their references.
\end{itemize}

\subsubsection{APK Alignment (zipalign)}

APK alignment is an optimization step that ensures all uncompressed resources inside an APK are aligned to specific byte boundaries.

\textbf{Why:} Proper alignment enables Android to memory-map resources using \texttt{mmap()}, avoiding redundant copying and reducing RAM usage and startup time.

\textbf{Details:}
\begin{itemize}
  \item Historically, alignment used 4-byte boundaries.
  \item Starting from Android 7.0 (API 24), some resource types (e.g., native libs, media) require 8- or 16-byte alignment.
\end{itemize}

\begin{lstlisting}[language=bash]
zipalign -v -p 4 app.apk aligned.apk
\end{lstlisting}

Gradle automatically runs \texttt{zipalign} on release builds.

\textbf{Focus Point:}  
Misaligned APKs can cause installation failures or degraded runtime performance. Always align APKs before signing.

\textbf{Deep Dive:}  
\texttt{zipalign} rewrites the APK such that all uncompressed entries start at an offset that satisfies alignment requirements. For example, native `.so` files may need 8- or 16-byte alignment so that the loader can directly map and execute them without copying to memory first.

\textbf{Focus Point:} 4-byte alignment is no longer sufficient for all resource types. Starting 2024, Google Play may enforce stricter alignment rules (8/16 bytes). Use modern build tools that ensure proper alignment per resource type.

\subsubsection{APK Signing}

APK signing is mandatory for all apps. It guarantees authenticity and integrity. Android enforces two signing schemes:

\begin{itemize}
  \item \textbf{v1 (JAR Signature):} Signs each file entry in \texttt{META-INF/}. Required for Android < 7.0.
  \item \textbf{v2 (APK Signature Scheme):} Signs the entire APK including file contents and structure. Required for Android 7.0+.
\end{itemize}

\textbf{Keystore types:}
\begin{itemize}
  \item \texttt{debug.keystore} — automatically generated for debug builds.
  \item \texttt{release keystore} — created and managed by the developer; used for production builds.
\end{itemize}

\begin{lstlisting}[language=Groovy]
signingConfigs {
    release {
        storeFile file("my-release-key.jks")
        storePassword "password"
        keyAlias "my-key-alias"
        keyPassword "key-password"
    }
}
\end{lstlisting}

\textbf{Focus Point:} Signing keys must be preserved. If lost, you cannot update your app on the Play Store. Use Google Play App Signing to delegate signing management to Google and support key rotation.

\textbf{Deep Dive: APK Signature Verification}

On install, Android verifies:
\begin{itemize}
  \item The APK is correctly signed with all required signature schemes.
  \item The public key matches any previous install (for updates).
  \item The APK hasn't been tampered with (integrity check).
\end{itemize}

On runtime, the system loads the signing certificate into the app’s identity (via \texttt{PackageInfo.signatures}) — this enables signature-based permission checks and signature matching (e.g., via \texttt{signature-level permissions} or content provider \texttt{uri permissions}).


\section{Version Control with Git}
\label{sec:git}

\subsection{Core Concepts}

\subsubsection{What is Git}

Git is a distributed version control system (VCS) that tracks changes to source code and enables collaboration. Every developer has a full copy of the project history locally, allowing commits, diffs, branches, and merges without a central server.

\textbf{Focus Point:} Git does not store file diffs but entire snapshots of files in each commit. Only files that change are stored again, using internal hashing and compression to reduce size.

\subsubsection{Distributed vs Centralized VCS}

\textbf{Centralized VCS} (e.g., SVN):
\begin{itemize}
  \item Single remote server holds the repository.
  \item Clients need a connection to commit, diff, or branch.
  \item Collaboration is simpler but limited in flexibility and resilience.
\end{itemize}

\textbf{Distributed VCS} (e.g., Git):
\begin{itemize}
  \item Each clone contains full history (commits, branches, tags).
  \item Allows full local history exploration and offline work.
  \item Push/pull operations are explicit and controlled.
\end{itemize}

\textbf{Focus Point:} In Git, \texttt{push} and \texttt{pull} are not automatic; they sync with remotes explicitly. Local history and branches exist independently of remote ones.

\subsubsection{Repository, Working Directory, Index}

\textbf{Repository}:
The full history of the project, stored in the \texttt{.git} directory. Contains objects (commits, blobs, trees), references (branches, tags), and configuration.

\textbf{Working Directory}:
The checked-out version of the project files that are visible and editable. Reflects the current state of the checked-out commit and staged changes.

\textbf{Index (Staging Area)}:
Intermediate layer between the working directory and repository. Holds the next snapshot to commit.

\textbf{Focus Point:} Git uses a three-stage model:
\begin{itemize}
  \item Edit in the working directory.
  \item Stage with \texttt{git add} (goes to index).
  \item Commit with \texttt{git commit} (goes to repo).
\end{itemize}

\subsubsection{Git Object Model: Blob, Tree, Commit, Tag}

Git stores all content as objects in a key-value database where keys are SHA-1 hashes.

\textbf{Blob}:
A snapshot of a file's contents. No filename, no metadata.

\textbf{Tree}:
A directory object that maps names to blobs (files) and other trees (subdirectories). It captures project structure.

\textbf{Commit}:
A pointer to a tree with metadata: author, date, message, and parent commit(s).

\begin{verbatim}
commit -----> tree -----> blob (file1.txt)
             |        \-> blob (file2.txt)
             \-> tree (subdir) -> blob
\end{verbatim}

\textbf{Tag}:
A human-readable reference to a specific commit. Can be lightweight (just pointer) or annotated (with metadata).

\textbf{Focus Point:} Git commits are not diffs. Each commit references an entire project tree, enabling fast diffs and history traversal without reconstructing changes from deltas.

\textbf{Deep Dive: Git Object Internals}

Every object (blob, tree, commit, tag) is stored as:
\begin{itemize}
  \item \texttt{<type> <size>\textbackslash0<content>} — compressed and hashed.
  \item Stored in \texttt{.git/objects/} under a SHA-1-derived path.
\end{itemize}

Example:
\begin{lstlisting}[language=bash]
echo "hello" | git hash-object --stdin -w
# -> writes a blob and returns its SHA-1
\end{lstlisting}

Git identifies objects purely by their content hash, ensuring integrity and deduplication.

\textbf{Focus Point:} Git is content-addressable: two identical files will produce the same blob hash, saving space across versions and branches.

\subsection{Basic Workflow}

\subsubsection{Creating and Cloning Repositories}

To initialize a new Git repository:

\begin{lstlisting}[language=bash]
git init
\end{lstlisting}

Creates a \texttt{.git} directory with all internal structures.

To clone an existing repository:

\begin{lstlisting}[language=bash]
git clone https://example.com/repo.git
\end{lstlisting}

\texttt{clone} performs:
\begin{itemize}
  \item A full copy of the remote repository (all branches, tags, objects).
  \item A checkout of the default branch (e.g., \texttt{main}).
\end{itemize}

\textbf{Focus Point:} Cloning is a full mirror of the repo history — not just the latest snapshot.

\subsubsection{Staging and Committing Changes}

After modifying files, changes must be staged before committing:

\begin{lstlisting}[language=bash]
git add file.txt
git commit -m "Describe change"
\end{lstlisting}

\texttt{git add} stages changes to the index. \texttt{git commit} snapshots the staged files to the repository.

To stage everything:

\begin{lstlisting}[language=bash]
git add .
\end{lstlisting}

\textbf{Focus Point:} Commits only record what’s staged, not what's currently in the working directory.

\subsubsection{Branches and Merging}

A branch is a movable pointer to a commit. Creating a branch:

\begin{lstlisting}[language=bash]
git checkout -b feature-x
\end{lstlisting}

Merging integrates changes from another branch:

\begin{lstlisting}[language=bash]
git merge feature-x
\end{lstlisting}

\texttt{merge} performs a three-way merge between the two tips and their common ancestor.

\textbf{Focus Point:} Always commit all staged changes before merging to avoid conflicts and ensure fast-forward optimization.

\subsubsection{Reset, Revert, Checkout}

\texttt{git reset} — moves the current \texttt{HEAD} and optionally updates index and working directory.

\begin{itemize}
  \item \texttt{--soft} → keep index and working dir.
  \item \texttt{--mixed} (default) → reset index.
  \item \texttt{--hard} → reset everything.
\end{itemize}

\begin{lstlisting}[language=bash]
git reset --hard HEAD~1
\end{lstlisting}

\texttt{git revert} — creates a new commit that undoes the effect of a previous commit.

\texttt{git checkout} — switch branches or restore files.

\begin{lstlisting}[language=bash]
git checkout main
git checkout -- file.txt  # discard changes
\end{lstlisting}

\textbf{Focus Point:} \texttt{reset} rewrites history (not safe on shared branches); \texttt{revert} preserves history with a compensating commit.

\subsubsection{Stash and Rebase}

\texttt{git stash} — temporarily saves changes in the working directory and index.

\begin{lstlisting}[language=bash]
git stash           # save
git stash apply     # restore
\end{lstlisting}

Useful when switching branches without committing work-in-progress.

\texttt{git rebase} — reapplies commits on top of a new base.

\begin{lstlisting}[language=bash]
git rebase main
\end{lstlisting}

Used to linearize history and avoid merge commits.

\textbf{Focus Point:} Use rebase for private history; never rebase published/shared branches.

\subsubsection{Viewing History with \texttt{git log}}

\texttt{git log} shows the commit history.

\begin{lstlisting}[language=bash]
git log --oneline --graph --decorate --all
\end{lstlisting}

Options:
\begin{itemize}
  \item \texttt{--oneline} — compact output.
  \item \texttt{--graph} — visual branch structure.
  \item \texttt{--patch} — show diffs per commit.
  \item \texttt{--since}, \texttt{--author} — filter history.
\end{itemize}

\textbf{Focus Point:} Git history is just a linked list of commits — each commit points to its parent(s). History is a DAG, not a linear sequence.

\subsection{Branching Strategies}

\subsubsection{Feature, Release, Task Branching}

Branching strategies isolate development concerns to improve collaboration and reduce integration risks.

\textbf{Feature Branching:}
\begin{itemize}
  \item Each feature is developed in its own branch off \texttt{main} or \texttt{develop}.
  \item Named descriptively: \texttt{feature/user-login}.
  \item Merged back via pull request or merge commit.
\end{itemize}

\textbf{Release Branching:}
\begin{itemize}
  \item Stabilization happens in a \texttt{release/x.y} branch.
  \item Only bugfixes, documentation, and versioning changes are allowed.
  \item Merged into \texttt{main} (for release) and \texttt{develop} (to propagate fixes).
\end{itemize}

\textbf{Task Branching:}
\begin{itemize}
  \item Short-lived branches for small tasks, bugfixes, or spikes.
  \item Often used with issue tracker integration (e.g., \texttt{bugfix/123-crash-on-login}).
\end{itemize}

\textbf{Focus Point:} Keep branches small, focused, and rebased regularly to reduce merge friction.

\subsubsection{Merging vs Rebasing}

\texttt{git merge} integrates commits preserving the original branch structure.

\begin{lstlisting}[language=bash]
git checkout main
git merge feature/login
\end{lstlisting}

Creates a merge commit (unless fast-forward is possible).

\texttt{git rebase} rewrites history by replaying commits on a new base.

\begin{lstlisting}[language=bash]
git checkout feature/login
git rebase main
\end{lstlisting}

\textbf{Comparison:}
\begin{itemize}
  \item \texttt{merge} is non-destructive; preserves full history.
  \item \texttt{rebase} produces a linear history; cleaner logs.
  \item \texttt{merge} retains original commit SHAs; \texttt{rebase} creates new SHAs.
\end{itemize}

\textbf{Focus Point:} Use \texttt{merge} for shared history and team collaboration; use \texttt{rebase} locally to maintain a clean commit history.

\subsubsection{Conflict Resolution and Abort Strategies}

Conflicts occur when Git cannot auto-merge two branches. These must be resolved manually.

\begin{lstlisting}[language=bash]
git merge feature-x
# conflict detected
# resolve in file
git add resolved_file.kt
git commit
\end{lstlisting}

To abort a merge or rebase:

\begin{lstlisting}[language=bash]
git merge --abort
git rebase --abort
\end{lstlisting}

Use \texttt{git status} to track conflicted files.

\textbf{Focus Point:} Conflicts are line-based. Avoid long-lived branches and frequent rebasing of shared branches to minimize conflicts.

\subsection{Remote Repositories}

\subsubsection{Fetching, Pulling, Pushing}

Remote repositories allow collaboration via centralized references to shared codebases.

\texttt{git fetch}: Downloads commits, refs, and tags from a remote without modifying the working directory.

\begin{lstlisting}[language=bash]
git fetch origin
\end{lstlisting}

\texttt{git pull}: Equivalent to \texttt{git fetch} followed by \texttt{git merge}.

\begin{lstlisting}[language=bash]
git pull origin main
\end{lstlisting}

\texttt{git push}: Uploads local commits to a remote branch. Requires upstream tracking or explicit destination.

\begin{lstlisting}[language=bash]
git push origin feature/login
\end{lstlisting}

\textbf{Focus Point:} Always fetch before pushing in shared branches to detect divergence early.

\subsubsection{Tracking and Remote Branches}

Remote branches are references to branches in a remote repository (e.g., \texttt{origin/main}).

A local branch can be linked to a remote with:

\begin{lstlisting}[language=bash]
git branch --set-upstream-to=origin/main main
\end{lstlisting}

or directly via clone or checkout:

\begin{lstlisting}[language=bash]
git checkout -b dev origin/dev
\end{lstlisting}

\texttt{git branch -vv} shows tracking info and remote status.

\textbf{Focus Point:} Push and pull operations on a tracking branch default to its upstream remote.

\subsubsection{Working Offline and Syncing Later}

Git is fully distributed; local operations (commits, branches, merges) are independent of network.

Workflow when offline:
\begin{itemize}
  \item Create and switch branches.
  \item Stage and commit as usual.
  \item Rebase or merge locally.
\end{itemize}

To sync after reconnecting:
\begin{lstlisting}[language=bash]
git fetch
git rebase origin/main  # or merge
git push
\end{lstlisting}

\textbf{Focus Point:} Use \texttt{rebase} to align with upstream before pushing to avoid unnecessary merge commits.

\subsection{Advanced Git Usage}

\subsubsection{Aliasing Commands}

Aliases simplify frequent or verbose Git commands via configuration.

\begin{lstlisting}[language=bash]
git config --global alias.co checkout
git config --global alias.st status
git config --global alias.lg "log --oneline --graph --all"
\end{lstlisting}

They are stored in \texttt{~/.gitconfig} under the \texttt{[alias]} section.

\textbf{Focus Point:} Aliases can encapsulate multi-option commands and improve speed and readability of CLI work.

\subsubsection{Using \texttt{.gitignore} Properly}

\texttt{.gitignore} defines patterns for files Git should ignore.

Example:

\begin{lstlisting}
# Ignore all log files
*.log

# Ignore build output
/build/
/out/

# Exclude a tracked file (won’t work retroactively)
!important.log
\end{lstlisting}

Tracked files are not affected; use \texttt{git rm --cached} to remove from index.

\textbf{Focus Point:} Add \texttt{.gitignore} early to avoid committing unnecessary files. Use global ignores for editor temp files.

\subsubsection{Inspecting Differences and Diffs}

\texttt{git diff} shows changes between:
\begin{itemize}
  \item Working directory vs index.
  \item Index vs last commit.
  \item Two commits, branches, or tags.
\end{itemize}

Examples:
\begin{lstlisting}[language=bash]
git diff                # unstaged changes
git diff --cached       # staged changes
git diff HEAD~1 HEAD    # diff between commits
\end{lstlisting}

\texttt{git log -p} adds patch diffs to commit history.

\textbf{Focus Point:} Combine \texttt{--stat}, \texttt{--name-only}, and \texttt{--color-words} for customized inspections.

\subsubsection{HEAD and Detached HEAD State}

\texttt{HEAD} is a pointer to the current commit checked out in your working directory.

In normal state:
\begin{lstlisting}
HEAD -> refs/heads/main
\end{lstlisting}

Detached HEAD means you are pointing directly to a commit, tag, or SHA (not a branch):

\begin{lstlisting}[language=bash]
git checkout a1b2c3d4
\end{lstlisting}

Commits made here will not belong to any branch unless explicitly saved.

\textbf{Focus Point:} Always create a branch if working in detached state to avoid losing commits:
\begin{lstlisting}[language=bash]
git checkout -b fix/urgent-fix
\end{lstlisting}

\subsubsection{Git Internals and Low-level Commands}

Git is fundamentally a content-addressable key–value store.

Objects:
\begin{itemize}
  \item \texttt{blob} — raw file content
  \item \texttt{tree} — directory structure
  \item \texttt{commit} — snapshot + metadata
  \item \texttt{tag} — named reference to an object
\end{itemize}

Stored in \texttt{.git/objects/} as compressed files named by their SHA-1 hash.

Inspect internals:

\begin{lstlisting}[language=bash]
git cat-file -p HEAD
git rev-parse HEAD
git ls-tree HEAD
\end{lstlisting}

\textbf{Deep Dive:} Git history is built from a DAG of commits referencing parents. Branches and tags are movable pointers to commits. \texttt{git reflog} tracks changes to HEAD for recovery.

\textbf{Focus Point:} Understanding low-level behavior helps in recovery, debugging, and custom automation.

\subsection{Best Practices}

\subsubsection{Atomic Commits and Messages}

Atomic commits encapsulate a single logical change and improve traceability.

\begin{itemize}
  \item Keep commits small and focused on one task or fix.
  \item Avoid mixing unrelated changes in the same commit (e.g., refactors and features).
  \item Write descriptive messages:
\end{itemize}

\begin{lstlisting}
feat(auth): add login form validation

Refactors the login screen to add inline error
messages for empty fields and invalid emails.
\end{lstlisting}

Use conventional prefixes like \texttt{feat}, \texttt{fix}, \texttt{refactor}, \texttt{docs} for better automation (e.g., changelogs, CI hooks).

\textbf{Focus Point:} Each commit should compile and pass tests — this supports easier bisecting and rollback.

\subsubsection{When to Merge vs Rebase}

\texttt{merge} and \texttt{rebase} are both used to integrate changes between branches, but have different semantics.

\textbf{Use \texttt{merge} when:}
\begin{itemize}
  \item You want to preserve full branch history.
  \item Working on shared feature branches with multiple contributors.
\end{itemize}

\textbf{Use \texttt{rebase} when:}
\begin{itemize}
  \item You want a linear, clean history (e.g., before merging to \texttt{main}).
  \item You’re updating local feature branches before PR.
\end{itemize}

\textbf{Focus Point:} Never rebase public branches that others might have based work on — this rewrites history and breaks sync.

\subsubsection{Minimal Conflict Strategies}

Minimize merge conflicts by:
\begin{itemize}
  \item Pulling frequently to rebase on top of shared progress.
  \item Avoiding long-lived feature branches.
  \item Isolating changes per file/module when possible.
  \item Using smaller commits and fast feedback loops.
\end{itemize}

Resolve conflicts manually and commit the resolution clearly. Use \texttt{git mergetool} for assisted resolution.

\textbf{Focus Point:} Conflicts are easier to resolve when commits are small and logically isolated.

\subsubsection{Clean History and Code Review Friendly Practices}

Maintain a reviewable history by:
\begin{itemize}
  \item Using squash merges after review to group changes.
  \item Writing clear commit messages that describe the "what" and "why".
  \item Avoiding WIP, "fix fix fix", or non-informative commit logs.
\end{itemize}

Use \texttt{git rebase -i} to clean up local commits before pushing.

\textbf{Focus Point:} A clean, readable commit history makes debugging, audits, and blame analysis significantly more effective.

\subsection{Bonus: Git Integration in Android Studio}

Android Studio provides built-in Git support that simplifies many version control operations through an intuitive UI. This section focuses on essential Git features directly available in the IDE.

\subsubsection{Cloning and Creating Repositories}

Clone a remote Git repository:
\begin{itemize}
  \item \texttt{File → New → Project from Version Control → Git}
  \item Paste the repository URL and set local directory.
\end{itemize}

Create a new Git repo:
\begin{itemize}
  \item \texttt{VCS → Enable Version Control → Git}
  \item The IDE initializes the repository and enables Git actions.
\end{itemize}

\subsubsection{Staging, Committing, and Pushing Changes}

Use the Version Control tool window (\textbf{Cmd}+9 / Alt+9):
\begin{itemize}
  \item Stage changes by checking the files.
  \item Write a commit message and click \texttt{Commit} or \texttt{Commit and Push}.
  \item Use \textbf{Cmd}+K / Ctrl+K to open the commit dialog quickly.
\end{itemize}

\textbf{Focus Point:} Use the diff panel before committing to review your changes line-by-line.

\subsubsection{Branch Management}

\begin{itemize}
  \item Switch, create, and delete branches from the bottom-right branch dropdown.
  \item Rebasing, merging, and checking out branches is available in the same menu.
\end{itemize}

\texttt{Git → Manage Branches...} shows all local and remote branches.

\textbf{Focus Point:} Avoid switching branches with uncommitted changes unless you're sure they won’t conflict.

\subsubsection{Conflict Resolution and History}

\begin{itemize}
  \item Merge conflicts are shown as a three-way diff in the editor.
  \item Use the arrows to select the correct lines, or edit manually.
  \item \texttt{Git → Show History} or right-click a file and choose \texttt{Git → Show History} to view changes.
\end{itemize}

\textbf{Focus Point:} The gutter diff markers let you view and revert changes inline before committing.

\subsubsection{Code Annotation (Blame) and Git Log}

\begin{itemize}
  \item Right-click a file → \texttt{Annotate} to see who last modified each line.
  \item \texttt{Git → Log} opens a powerful graphical history viewer with search, filtering, and branch comparison.
\end{itemize}

\subsubsection{Rebase, Cherry-pick, and Stash from UI}

\begin{itemize}
  \item Right-click commits in the log to rebase, cherry-pick, or reset.
  \item \texttt{Git → Stash Changes} to temporarily shelve work.
  \item \texttt{Git → Unstash Changes} to apply them later.
\end{itemize}

\textbf{Focus Point:} Rebase and stash operations are non-destructive if used correctly; always double-check the base and scope of your operations.

\subsubsection{Common Shortcuts}

\begin{tabular}{|l|l|}
\hline
\textbf{Action} & \textbf{Shortcut} \\
\hline
Commit & \textbf{Cmd}+K / Ctrl+K \\
Push & \textbf{Cmd}+\textbf{Shift}+K / Ctrl+Shift+K \\
Update (pull + rebase/merge) & \textbf{Cmd}+T / Ctrl+T \\
View Git Log & \textbf{Cmd}+9 / Alt+9 → Log tab \\
Annotate (Blame) & Right-click → Annotate \\
\hline
\end{tabular}

\textbf{Focus Point:} Mastering Git inside Android Studio accelerates development, prevents errors, and allows fine-grained control over history.

\clearpage
\section*{Contributors}
\addcontentsline{toc}{section}{Contributors}

\textbf{Author:} Arthur Mikulski

\textbf{Last Updated:} \today

\end{document}